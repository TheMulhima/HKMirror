using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
namespace HKMirror.Hooks.OnHooks;
/// <summary>
/// Contains different types of On Hooks for AchievementsList class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnAchievementsList
{
internal static class HookHandler
{
private static List<string> HookedList = new List<string>();
internal static void HookFindAchievement()
{
if (!HookedList.Contains("FindAchievement"))
{
HookedList.Add("FindAchievement");
On.AchievementsList.FindAchievement += FindAchievement;

}
}
internal static event Delegates.FindAchievement_BeforeArgs _beforeFindAchievement;
internal static event Delegates.FindAchievement_AfterArgs _afterFindAchievement;
private static Achievement FindAchievement(On.AchievementsList.orig_FindAchievement orig,AchievementsList self,  string key)
{
Delegates.Params_FindAchievement @params = new() 
{
self = self
, key = key
};
if (_beforeFindAchievement != null)
{
foreach (Delegates.FindAchievement_BeforeArgs toInvoke in _beforeFindAchievement.GetInvocationList())
{
try
{
_beforeFindAchievement?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
key = @params.key;
var retVal = orig(self, key);
if (_afterFindAchievement != null)
{
foreach (Delegates.FindAchievement_AfterArgs toInvoke in _afterFindAchievement.GetInvocationList())
{
try
{
retVal = _afterFindAchievement.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookAchievementExists()
{
if (!HookedList.Contains("AchievementExists"))
{
HookedList.Add("AchievementExists");
On.AchievementsList.AchievementExists += AchievementExists;

}
}
internal static event Delegates.AchievementExists_BeforeArgs _beforeAchievementExists;
internal static event Delegates.AchievementExists_AfterArgs _afterAchievementExists;
private static bool AchievementExists(On.AchievementsList.orig_AchievementExists orig,AchievementsList self,  string key)
{
Delegates.Params_AchievementExists @params = new() 
{
self = self
, key = key
};
if (_beforeAchievementExists != null)
{
foreach (Delegates.AchievementExists_BeforeArgs toInvoke in _beforeAchievementExists.GetInvocationList())
{
try
{
_beforeAchievementExists?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
key = @params.key;
var retVal = orig(self, key);
if (_afterAchievementExists != null)
{
foreach (Delegates.AchievementExists_AfterArgs toInvoke in _afterAchievementExists.GetInvocationList())
{
try
{
retVal = _afterAchievementExists.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
}

/// <summary>
/// Contains necessary information to create Hooks. Does not contain any hooks
/// </summary>
public static class Delegates
{
public sealed class Params_FindAchievement
{
public AchievementsList self;
public string key;
}
public delegate void FindAchievement_BeforeArgs(Params_FindAchievement args);
public delegate Achievement FindAchievement_AfterArgs(Params_FindAchievement args, Achievement ret);
public delegate Achievement FindAchievement_WithArgs (Func<AchievementsList,  string, Achievement> orig, AchievementsList self,  string key);
public sealed class Params_AchievementExists
{
public AchievementsList self;
public string key;
}
public delegate void AchievementExists_BeforeArgs(Params_AchievementExists args);
public delegate bool AchievementExists_AfterArgs(Params_AchievementExists args, bool ret);
public delegate bool AchievementExists_WithArgs (Func<AchievementsList,  string, bool> orig, AchievementsList self,  string key);
}

/// <summary>
/// Contains Hooks to that run code before orig(self) is called
/// </summary>
public static class BeforeOrig
{
public static event Delegates.FindAchievement_BeforeArgs FindAchievement
{
add
{

HookHandler._beforeFindAchievement += value;
HookHandler.HookFindAchievement();
}
remove => HookHandler._beforeFindAchievement -= value;
}
public static event Delegates.AchievementExists_BeforeArgs AchievementExists
{
add
{

HookHandler._beforeAchievementExists += value;
HookHandler.HookAchievementExists();
}
remove => HookHandler._beforeAchievementExists -= value;
}
}

/// <summary>
/// Contains Hooks to that run code after orig(self) is called
/// </summary>
public static class AfterOrig
{
public static event Delegates.FindAchievement_AfterArgs FindAchievement
{
add
{

HookHandler._afterFindAchievement += value;
HookHandler.HookFindAchievement();
}
remove => HookHandler._afterFindAchievement -= value;
}
public static event Delegates.AchievementExists_AfterArgs AchievementExists
{
add
{

HookHandler._afterAchievementExists += value;
HookHandler.HookAchievementExists();
}
remove => HookHandler._afterAchievementExists -= value;
}
}

/// <summary>
/// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
/// </summary>
public static class WithOrig
{
public static event On.AchievementsList.hook_FindAchievement FindAchievement
{
add => On.AchievementsList.FindAchievement += value;
remove => On.AchievementsList.FindAchievement -= value;
}
public static event On.AchievementsList.hook_AchievementExists AchievementExists
{
add => On.AchievementsList.AchievementExists += value;
remove => On.AchievementsList.AchievementExists -= value;
}
}

}

using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
namespace HKMirror.Hooks.OnHooks;
/// <summary>
/// Contains different types of On Hooks for ColorChannel class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnColorChannel
{
internal static class HookHandler
{
private static List<string> HookedList = new List<string>();
internal static void HookInit()
{
if (!HookedList.Contains("Init"))
{
HookedList.Add("Init");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Init", true), Init);

}
}
internal static event Delegates.Init_BeforeArgs _beforeInit;
internal static event Delegates.Init_AfterArgs _afterInit;
private static void Init(Action<tk2dRuntime.TileMap.ColorChannel,  int,  int,  int,  int> orig, tk2dRuntime.TileMap.ColorChannel self,  int width,  int height,  int divX,  int divY)
{
Delegates.Params_Init @params = new() 
{
self = self
, width = width
, height = height
, divX = divX
, divY = divY
};
if (_beforeInit != null)
{
foreach (Delegates.Init_BeforeArgs toInvoke in _beforeInit.GetInvocationList())
{
try
{
_beforeInit?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
width = @params.width;
height = @params.height;
divX = @params.divX;
divY = @params.divY;
orig(self, width, height, divX, divY);
if (_afterInit != null)
{
foreach (Delegates.Init_AfterArgs toInvoke in _afterInit.GetInvocationList())
{
try
{
_afterInit.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookFindChunkAndCoordinate()
{
if (!HookedList.Contains("FindChunkAndCoordinate"))
{
HookedList.Add("FindChunkAndCoordinate");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "FindChunkAndCoordinate", true), FindChunkAndCoordinate);

}
}
internal static event Delegates.FindChunkAndCoordinate_BeforeArgs _beforeFindChunkAndCoordinate;
internal static event Delegates.FindChunkAndCoordinate_AfterArgs _afterFindChunkAndCoordinate;
private static tk2dRuntime.TileMap.ColorChunk FindChunkAndCoordinate(Func<tk2dRuntime.TileMap.ColorChannel,  int,  int,  int, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  int offset)
{
Delegates.Params_FindChunkAndCoordinate @params = new() 
{
self = self
, x = x
, y = y
, offset = offset
};
if (_beforeFindChunkAndCoordinate != null)
{
foreach (Delegates.FindChunkAndCoordinate_BeforeArgs toInvoke in _beforeFindChunkAndCoordinate.GetInvocationList())
{
try
{
_beforeFindChunkAndCoordinate?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
x = @params.x;
y = @params.y;
offset = @params.offset;
var retVal = orig(self, x, y, offset);
if (_afterFindChunkAndCoordinate != null)
{
foreach (Delegates.FindChunkAndCoordinate_AfterArgs toInvoke in _afterFindChunkAndCoordinate.GetInvocationList())
{
try
{
retVal = _afterFindChunkAndCoordinate.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookGetColor()
{
if (!HookedList.Contains("GetColor"))
{
HookedList.Add("GetColor");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetColor", true), GetColor);

}
}
internal static event Delegates.GetColor_BeforeArgs _beforeGetColor;
internal static event Delegates.GetColor_AfterArgs _afterGetColor;
private static UnityEngine.Color GetColor(Func<tk2dRuntime.TileMap.ColorChannel,  int,  int, UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y)
{
Delegates.Params_GetColor @params = new() 
{
self = self
, x = x
, y = y
};
if (_beforeGetColor != null)
{
foreach (Delegates.GetColor_BeforeArgs toInvoke in _beforeGetColor.GetInvocationList())
{
try
{
_beforeGetColor?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
x = @params.x;
y = @params.y;
var retVal = orig(self, x, y);
if (_afterGetColor != null)
{
foreach (Delegates.GetColor_AfterArgs toInvoke in _afterGetColor.GetInvocationList())
{
try
{
retVal = _afterGetColor.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookInitChunk()
{
if (!HookedList.Contains("InitChunk"))
{
HookedList.Add("InitChunk");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "InitChunk", true), InitChunk);

}
}
internal static event Delegates.InitChunk_BeforeArgs _beforeInitChunk;
internal static event Delegates.InitChunk_AfterArgs _afterInitChunk;
private static void InitChunk(Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk)
{
Delegates.Params_InitChunk @params = new() 
{
self = self
, chunk = chunk
};
if (_beforeInitChunk != null)
{
foreach (Delegates.InitChunk_BeforeArgs toInvoke in _beforeInitChunk.GetInvocationList())
{
try
{
_beforeInitChunk?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
chunk = @params.chunk;
orig(self, chunk);
if (_afterInitChunk != null)
{
foreach (Delegates.InitChunk_AfterArgs toInvoke in _afterInitChunk.GetInvocationList())
{
try
{
_afterInitChunk.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookSetColor()
{
if (!HookedList.Contains("SetColor"))
{
HookedList.Add("SetColor");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "SetColor", true), SetColor);

}
}
internal static event Delegates.SetColor_BeforeArgs _beforeSetColor;
internal static event Delegates.SetColor_AfterArgs _afterSetColor;
private static void SetColor(Action<tk2dRuntime.TileMap.ColorChannel,  int,  int,  UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  UnityEngine.Color color)
{
Delegates.Params_SetColor @params = new() 
{
self = self
, x = x
, y = y
, color = color
};
if (_beforeSetColor != null)
{
foreach (Delegates.SetColor_BeforeArgs toInvoke in _beforeSetColor.GetInvocationList())
{
try
{
_beforeSetColor?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
x = @params.x;
y = @params.y;
color = @params.color;
orig(self, x, y, color);
if (_afterSetColor != null)
{
foreach (Delegates.SetColor_AfterArgs toInvoke in _afterSetColor.GetInvocationList())
{
try
{
_afterSetColor.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookGetChunk_int_int()
{
if (!HookedList.Contains("GetChunk_int_int"))
{
HookedList.Add("GetChunk_int_int");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk_int_int", true), GetChunk_int_int);

}
}
internal static event Delegates.GetChunk_int_int_BeforeArgs _beforeGetChunk_int_int;
internal static event Delegates.GetChunk_int_int_AfterArgs _afterGetChunk_int_int;
private static tk2dRuntime.TileMap.ColorChunk GetChunk_int_int(Func<tk2dRuntime.TileMap.ColorChannel,  int,  int, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y)
{
Delegates.Params_GetChunk_int_int @params = new() 
{
self = self
, x = x
, y = y
};
if (_beforeGetChunk_int_int != null)
{
foreach (Delegates.GetChunk_int_int_BeforeArgs toInvoke in _beforeGetChunk_int_int.GetInvocationList())
{
try
{
_beforeGetChunk_int_int?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
x = @params.x;
y = @params.y;
var retVal = orig(self, x, y);
if (_afterGetChunk_int_int != null)
{
foreach (Delegates.GetChunk_int_int_AfterArgs toInvoke in _afterGetChunk_int_int.GetInvocationList())
{
try
{
retVal = _afterGetChunk_int_int.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookGetChunk_int_int_bool()
{
if (!HookedList.Contains("GetChunk_int_int_bool"))
{
HookedList.Add("GetChunk_int_int_bool");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk_int_int_bool", true), GetChunk_int_int_bool);

}
}
internal static event Delegates.GetChunk_int_int_bool_BeforeArgs _beforeGetChunk_int_int_bool;
internal static event Delegates.GetChunk_int_int_bool_AfterArgs _afterGetChunk_int_int_bool;
private static tk2dRuntime.TileMap.ColorChunk GetChunk_int_int_bool(Func<tk2dRuntime.TileMap.ColorChannel,  int,  int,  bool, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  bool init)
{
Delegates.Params_GetChunk_int_int_bool @params = new() 
{
self = self
, x = x
, y = y
, init = init
};
if (_beforeGetChunk_int_int_bool != null)
{
foreach (Delegates.GetChunk_int_int_bool_BeforeArgs toInvoke in _beforeGetChunk_int_int_bool.GetInvocationList())
{
try
{
_beforeGetChunk_int_int_bool?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
x = @params.x;
y = @params.y;
init = @params.init;
var retVal = orig(self, x, y, init);
if (_afterGetChunk_int_int_bool != null)
{
foreach (Delegates.GetChunk_int_int_bool_AfterArgs toInvoke in _afterGetChunk_int_int_bool.GetInvocationList())
{
try
{
retVal = _afterGetChunk_int_int_bool.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookClearChunk()
{
if (!HookedList.Contains("ClearChunk"))
{
HookedList.Add("ClearChunk");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearChunk", true), ClearChunk);

}
}
internal static event Delegates.ClearChunk_BeforeArgs _beforeClearChunk;
internal static event Delegates.ClearChunk_AfterArgs _afterClearChunk;
private static void ClearChunk(Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk)
{
Delegates.Params_ClearChunk @params = new() 
{
self = self
, chunk = chunk
};
if (_beforeClearChunk != null)
{
foreach (Delegates.ClearChunk_BeforeArgs toInvoke in _beforeClearChunk.GetInvocationList())
{
try
{
_beforeClearChunk?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
chunk = @params.chunk;
orig(self, chunk);
if (_afterClearChunk != null)
{
foreach (Delegates.ClearChunk_AfterArgs toInvoke in _afterClearChunk.GetInvocationList())
{
try
{
_afterClearChunk.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookClearDirtyFlag()
{
if (!HookedList.Contains("ClearDirtyFlag"))
{
HookedList.Add("ClearDirtyFlag");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearDirtyFlag", true), ClearDirtyFlag);

}
}
internal static event Delegates.ClearDirtyFlag_BeforeArgs _beforeClearDirtyFlag;
internal static event Delegates.ClearDirtyFlag_AfterArgs _afterClearDirtyFlag;
private static void ClearDirtyFlag(Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_ClearDirtyFlag @params = new() 
{
self = self
};
if (_beforeClearDirtyFlag != null)
{
foreach (Delegates.ClearDirtyFlag_BeforeArgs toInvoke in _beforeClearDirtyFlag.GetInvocationList())
{
try
{
_beforeClearDirtyFlag?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterClearDirtyFlag != null)
{
foreach (Delegates.ClearDirtyFlag_AfterArgs toInvoke in _afterClearDirtyFlag.GetInvocationList())
{
try
{
_afterClearDirtyFlag.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookClear()
{
if (!HookedList.Contains("Clear"))
{
HookedList.Add("Clear");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Clear", true), Clear);

}
}
internal static event Delegates.Clear_BeforeArgs _beforeClear;
internal static event Delegates.Clear_AfterArgs _afterClear;
private static void Clear(Action<tk2dRuntime.TileMap.ColorChannel,  UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  UnityEngine.Color color)
{
Delegates.Params_Clear @params = new() 
{
self = self
, color = color
};
if (_beforeClear != null)
{
foreach (Delegates.Clear_BeforeArgs toInvoke in _beforeClear.GetInvocationList())
{
try
{
_beforeClear?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
color = @params.color;
orig(self, color);
if (_afterClear != null)
{
foreach (Delegates.Clear_AfterArgs toInvoke in _afterClear.GetInvocationList())
{
try
{
_afterClear.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookDelete()
{
if (!HookedList.Contains("Delete"))
{
HookedList.Add("Delete");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Delete", true), Delete);

}
}
internal static event Delegates.Delete_BeforeArgs _beforeDelete;
internal static event Delegates.Delete_AfterArgs _afterDelete;
private static void Delete(Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_Delete @params = new() 
{
self = self
};
if (_beforeDelete != null)
{
foreach (Delegates.Delete_BeforeArgs toInvoke in _beforeDelete.GetInvocationList())
{
try
{
_beforeDelete?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterDelete != null)
{
foreach (Delegates.Delete_AfterArgs toInvoke in _afterDelete.GetInvocationList())
{
try
{
_afterDelete.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookCreate()
{
if (!HookedList.Contains("Create"))
{
HookedList.Add("Create");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Create", true), Create);

}
}
internal static event Delegates.Create_BeforeArgs _beforeCreate;
internal static event Delegates.Create_AfterArgs _afterCreate;
private static void Create(Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_Create @params = new() 
{
self = self
};
if (_beforeCreate != null)
{
foreach (Delegates.Create_BeforeArgs toInvoke in _beforeCreate.GetInvocationList())
{
try
{
_beforeCreate?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterCreate != null)
{
foreach (Delegates.Create_AfterArgs toInvoke in _afterCreate.GetInvocationList())
{
try
{
_afterCreate.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookOptimize_ColorChunk()
{
if (!HookedList.Contains("Optimize_ColorChunk"))
{
HookedList.Add("Optimize_ColorChunk");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize_ColorChunk", true), Optimize_ColorChunk);

}
}
internal static event Delegates.Optimize_ColorChunk_BeforeArgs _beforeOptimize_ColorChunk;
internal static event Delegates.Optimize_ColorChunk_AfterArgs _afterOptimize_ColorChunk;
private static void Optimize_ColorChunk(Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk)
{
Delegates.Params_Optimize_ColorChunk @params = new() 
{
self = self
, chunk = chunk
};
if (_beforeOptimize_ColorChunk != null)
{
foreach (Delegates.Optimize_ColorChunk_BeforeArgs toInvoke in _beforeOptimize_ColorChunk.GetInvocationList())
{
try
{
_beforeOptimize_ColorChunk?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
chunk = @params.chunk;
orig(self, chunk);
if (_afterOptimize_ColorChunk != null)
{
foreach (Delegates.Optimize_ColorChunk_AfterArgs toInvoke in _afterOptimize_ColorChunk.GetInvocationList())
{
try
{
_afterOptimize_ColorChunk.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookOptimize()
{
if (!HookedList.Contains("Optimize"))
{
HookedList.Add("Optimize");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize", true), Optimize);

}
}
internal static event Delegates.Optimize_BeforeArgs _beforeOptimize;
internal static event Delegates.Optimize_AfterArgs _afterOptimize;
private static void Optimize(Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_Optimize @params = new() 
{
self = self
};
if (_beforeOptimize != null)
{
foreach (Delegates.Optimize_BeforeArgs toInvoke in _beforeOptimize.GetInvocationList())
{
try
{
_beforeOptimize?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterOptimize != null)
{
foreach (Delegates.Optimize_AfterArgs toInvoke in _afterOptimize.GetInvocationList())
{
try
{
_afterOptimize.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void Hookget_IsEmpty()
{
if (!HookedList.Contains("get_IsEmpty"))
{
HookedList.Add("get_IsEmpty");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_IsEmpty", true), get_IsEmpty);

}
}
internal static event Delegates.get_IsEmpty_BeforeArgs _beforeget_IsEmpty;
internal static event Delegates.get_IsEmpty_AfterArgs _afterget_IsEmpty;
private static bool get_IsEmpty(Func<tk2dRuntime.TileMap.ColorChannel, bool> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_get_IsEmpty @params = new() 
{
self = self
};
if (_beforeget_IsEmpty != null)
{
foreach (Delegates.get_IsEmpty_BeforeArgs toInvoke in _beforeget_IsEmpty.GetInvocationList())
{
try
{
_beforeget_IsEmpty?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
var retVal = orig(self);
if (_afterget_IsEmpty != null)
{
foreach (Delegates.get_IsEmpty_AfterArgs toInvoke in _afterget_IsEmpty.GetInvocationList())
{
try
{
retVal = _afterget_IsEmpty.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void Hookget_NumActiveChunks()
{
if (!HookedList.Contains("get_NumActiveChunks"))
{
HookedList.Add("get_NumActiveChunks");
new Hook(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_NumActiveChunks", true), get_NumActiveChunks);

}
}
internal static event Delegates.get_NumActiveChunks_BeforeArgs _beforeget_NumActiveChunks;
internal static event Delegates.get_NumActiveChunks_AfterArgs _afterget_NumActiveChunks;
private static int get_NumActiveChunks(Func<tk2dRuntime.TileMap.ColorChannel, int> orig, tk2dRuntime.TileMap.ColorChannel self)
{
Delegates.Params_get_NumActiveChunks @params = new() 
{
self = self
};
if (_beforeget_NumActiveChunks != null)
{
foreach (Delegates.get_NumActiveChunks_BeforeArgs toInvoke in _beforeget_NumActiveChunks.GetInvocationList())
{
try
{
_beforeget_NumActiveChunks?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
var retVal = orig(self);
if (_afterget_NumActiveChunks != null)
{
foreach (Delegates.get_NumActiveChunks_AfterArgs toInvoke in _afterget_NumActiveChunks.GetInvocationList())
{
try
{
retVal = _afterget_NumActiveChunks.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
}

/// <summary>
/// Contains necessary information to create Hooks. Does not contain any hooks
/// </summary>
public static class Delegates
{
public sealed class Params_Init
{
public tk2dRuntime.TileMap.ColorChannel self;
public int width;
public int height;
public int divX;
public int divY;
}
public delegate void Init_BeforeArgs(Params_Init args);
public delegate void Init_AfterArgs(Params_Init args);
public delegate void Init_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  int,  int,  int,  int> orig, tk2dRuntime.TileMap.ColorChannel self,  int width,  int height,  int divX,  int divY);
public sealed class Params_FindChunkAndCoordinate
{
public tk2dRuntime.TileMap.ColorChannel self;
public int x;
public int y;
public int offset;
}
public delegate void FindChunkAndCoordinate_BeforeArgs(Params_FindChunkAndCoordinate args);
public delegate tk2dRuntime.TileMap.ColorChunk FindChunkAndCoordinate_AfterArgs(Params_FindChunkAndCoordinate args, tk2dRuntime.TileMap.ColorChunk ret);
public delegate tk2dRuntime.TileMap.ColorChunk FindChunkAndCoordinate_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel,  int,  int,  int, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  int offset);
public sealed class Params_GetColor
{
public tk2dRuntime.TileMap.ColorChannel self;
public int x;
public int y;
}
public delegate void GetColor_BeforeArgs(Params_GetColor args);
public delegate UnityEngine.Color GetColor_AfterArgs(Params_GetColor args, UnityEngine.Color ret);
public delegate UnityEngine.Color GetColor_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel,  int,  int, UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y);
public sealed class Params_InitChunk
{
public tk2dRuntime.TileMap.ColorChannel self;
public tk2dRuntime.TileMap.ColorChunk chunk;
}
public delegate void InitChunk_BeforeArgs(Params_InitChunk args);
public delegate void InitChunk_AfterArgs(Params_InitChunk args);
public delegate void InitChunk_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk);
public sealed class Params_SetColor
{
public tk2dRuntime.TileMap.ColorChannel self;
public int x;
public int y;
public UnityEngine.Color color;
}
public delegate void SetColor_BeforeArgs(Params_SetColor args);
public delegate void SetColor_AfterArgs(Params_SetColor args);
public delegate void SetColor_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  int,  int,  UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  UnityEngine.Color color);
public sealed class Params_GetChunk_int_int
{
public tk2dRuntime.TileMap.ColorChannel self;
public int x;
public int y;
}
public delegate void GetChunk_int_int_BeforeArgs(Params_GetChunk_int_int args);
public delegate tk2dRuntime.TileMap.ColorChunk GetChunk_int_int_AfterArgs(Params_GetChunk_int_int args, tk2dRuntime.TileMap.ColorChunk ret);
public delegate tk2dRuntime.TileMap.ColorChunk GetChunk_int_int_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel,  int,  int, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y);
public sealed class Params_GetChunk_int_int_bool
{
public tk2dRuntime.TileMap.ColorChannel self;
public int x;
public int y;
public bool init;
}
public delegate void GetChunk_int_int_bool_BeforeArgs(Params_GetChunk_int_int_bool args);
public delegate tk2dRuntime.TileMap.ColorChunk GetChunk_int_int_bool_AfterArgs(Params_GetChunk_int_int_bool args, tk2dRuntime.TileMap.ColorChunk ret);
public delegate tk2dRuntime.TileMap.ColorChunk GetChunk_int_int_bool_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel,  int,  int,  bool, tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  int x,  int y,  bool init);
public sealed class Params_ClearChunk
{
public tk2dRuntime.TileMap.ColorChannel self;
public tk2dRuntime.TileMap.ColorChunk chunk;
}
public delegate void ClearChunk_BeforeArgs(Params_ClearChunk args);
public delegate void ClearChunk_AfterArgs(Params_ClearChunk args);
public delegate void ClearChunk_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk);
public sealed class Params_ClearDirtyFlag
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void ClearDirtyFlag_BeforeArgs(Params_ClearDirtyFlag args);
public delegate void ClearDirtyFlag_AfterArgs(Params_ClearDirtyFlag args);
public delegate void ClearDirtyFlag_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self);
public sealed class Params_Clear
{
public tk2dRuntime.TileMap.ColorChannel self;
public UnityEngine.Color color;
}
public delegate void Clear_BeforeArgs(Params_Clear args);
public delegate void Clear_AfterArgs(Params_Clear args);
public delegate void Clear_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  UnityEngine.Color> orig, tk2dRuntime.TileMap.ColorChannel self,  UnityEngine.Color color);
public sealed class Params_Delete
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void Delete_BeforeArgs(Params_Delete args);
public delegate void Delete_AfterArgs(Params_Delete args);
public delegate void Delete_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self);
public sealed class Params_Create
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void Create_BeforeArgs(Params_Create args);
public delegate void Create_AfterArgs(Params_Create args);
public delegate void Create_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self);
public sealed class Params_Optimize_ColorChunk
{
public tk2dRuntime.TileMap.ColorChannel self;
public tk2dRuntime.TileMap.ColorChunk chunk;
}
public delegate void Optimize_ColorChunk_BeforeArgs(Params_Optimize_ColorChunk args);
public delegate void Optimize_ColorChunk_AfterArgs(Params_Optimize_ColorChunk args);
public delegate void Optimize_ColorChunk_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel,  tk2dRuntime.TileMap.ColorChunk> orig, tk2dRuntime.TileMap.ColorChannel self,  tk2dRuntime.TileMap.ColorChunk chunk);
public sealed class Params_Optimize
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void Optimize_BeforeArgs(Params_Optimize args);
public delegate void Optimize_AfterArgs(Params_Optimize args);
public delegate void Optimize_WithArgs (Action<tk2dRuntime.TileMap.ColorChannel> orig, tk2dRuntime.TileMap.ColorChannel self);
public sealed class Params_get_IsEmpty
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void get_IsEmpty_BeforeArgs(Params_get_IsEmpty args);
public delegate bool get_IsEmpty_AfterArgs(Params_get_IsEmpty args, bool ret);
public delegate bool get_IsEmpty_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel, bool> orig, tk2dRuntime.TileMap.ColorChannel self);
public sealed class Params_get_NumActiveChunks
{
public tk2dRuntime.TileMap.ColorChannel self;
}
public delegate void get_NumActiveChunks_BeforeArgs(Params_get_NumActiveChunks args);
public delegate int get_NumActiveChunks_AfterArgs(Params_get_NumActiveChunks args, int ret);
public delegate int get_NumActiveChunks_WithArgs (Func<tk2dRuntime.TileMap.ColorChannel, int> orig, tk2dRuntime.TileMap.ColorChannel self);
}

/// <summary>
/// Contains Hooks to that run code before orig(self) is called
/// </summary>
public static class BeforeOrig
{
public static event Delegates.Init_BeforeArgs Init
{
add
{

HookHandler._beforeInit += value;
HookHandler.HookInit();
}
remove => HookHandler._beforeInit -= value;
}
public static event Delegates.FindChunkAndCoordinate_BeforeArgs FindChunkAndCoordinate
{
add
{

HookHandler._beforeFindChunkAndCoordinate += value;
HookHandler.HookFindChunkAndCoordinate();
}
remove => HookHandler._beforeFindChunkAndCoordinate -= value;
}
public static event Delegates.GetColor_BeforeArgs GetColor
{
add
{

HookHandler._beforeGetColor += value;
HookHandler.HookGetColor();
}
remove => HookHandler._beforeGetColor -= value;
}
public static event Delegates.InitChunk_BeforeArgs InitChunk
{
add
{

HookHandler._beforeInitChunk += value;
HookHandler.HookInitChunk();
}
remove => HookHandler._beforeInitChunk -= value;
}
public static event Delegates.SetColor_BeforeArgs SetColor
{
add
{

HookHandler._beforeSetColor += value;
HookHandler.HookSetColor();
}
remove => HookHandler._beforeSetColor -= value;
}
public static event Delegates.GetChunk_int_int_BeforeArgs GetChunk_int_int
{
add
{

HookHandler._beforeGetChunk_int_int += value;
HookHandler.HookGetChunk_int_int();
}
remove => HookHandler._beforeGetChunk_int_int -= value;
}
public static event Delegates.GetChunk_int_int_bool_BeforeArgs GetChunk_int_int_bool
{
add
{

HookHandler._beforeGetChunk_int_int_bool += value;
HookHandler.HookGetChunk_int_int_bool();
}
remove => HookHandler._beforeGetChunk_int_int_bool -= value;
}
public static event Delegates.ClearChunk_BeforeArgs ClearChunk
{
add
{

HookHandler._beforeClearChunk += value;
HookHandler.HookClearChunk();
}
remove => HookHandler._beforeClearChunk -= value;
}
public static event Delegates.ClearDirtyFlag_BeforeArgs ClearDirtyFlag
{
add
{

HookHandler._beforeClearDirtyFlag += value;
HookHandler.HookClearDirtyFlag();
}
remove => HookHandler._beforeClearDirtyFlag -= value;
}
public static event Delegates.Clear_BeforeArgs Clear
{
add
{

HookHandler._beforeClear += value;
HookHandler.HookClear();
}
remove => HookHandler._beforeClear -= value;
}
public static event Delegates.Delete_BeforeArgs Delete
{
add
{

HookHandler._beforeDelete += value;
HookHandler.HookDelete();
}
remove => HookHandler._beforeDelete -= value;
}
public static event Delegates.Create_BeforeArgs Create
{
add
{

HookHandler._beforeCreate += value;
HookHandler.HookCreate();
}
remove => HookHandler._beforeCreate -= value;
}
public static event Delegates.Optimize_ColorChunk_BeforeArgs Optimize_ColorChunk
{
add
{

HookHandler._beforeOptimize_ColorChunk += value;
HookHandler.HookOptimize_ColorChunk();
}
remove => HookHandler._beforeOptimize_ColorChunk -= value;
}
public static event Delegates.Optimize_BeforeArgs Optimize
{
add
{

HookHandler._beforeOptimize += value;
HookHandler.HookOptimize();
}
remove => HookHandler._beforeOptimize -= value;
}
public static event Delegates.get_IsEmpty_BeforeArgs get_IsEmpty
{
add
{

HookHandler._beforeget_IsEmpty += value;
HookHandler.Hookget_IsEmpty();
}
remove => HookHandler._beforeget_IsEmpty -= value;
}
public static event Delegates.get_NumActiveChunks_BeforeArgs get_NumActiveChunks
{
add
{

HookHandler._beforeget_NumActiveChunks += value;
HookHandler.Hookget_NumActiveChunks();
}
remove => HookHandler._beforeget_NumActiveChunks -= value;
}
}

/// <summary>
/// Contains Hooks to that run code after orig(self) is called
/// </summary>
public static class AfterOrig
{
public static event Delegates.Init_AfterArgs Init
{
add
{

HookHandler._afterInit += value;
HookHandler.HookInit();
}
remove => HookHandler._afterInit -= value;
}
public static event Delegates.FindChunkAndCoordinate_AfterArgs FindChunkAndCoordinate
{
add
{

HookHandler._afterFindChunkAndCoordinate += value;
HookHandler.HookFindChunkAndCoordinate();
}
remove => HookHandler._afterFindChunkAndCoordinate -= value;
}
public static event Delegates.GetColor_AfterArgs GetColor
{
add
{

HookHandler._afterGetColor += value;
HookHandler.HookGetColor();
}
remove => HookHandler._afterGetColor -= value;
}
public static event Delegates.InitChunk_AfterArgs InitChunk
{
add
{

HookHandler._afterInitChunk += value;
HookHandler.HookInitChunk();
}
remove => HookHandler._afterInitChunk -= value;
}
public static event Delegates.SetColor_AfterArgs SetColor
{
add
{

HookHandler._afterSetColor += value;
HookHandler.HookSetColor();
}
remove => HookHandler._afterSetColor -= value;
}
public static event Delegates.GetChunk_int_int_AfterArgs GetChunk_int_int
{
add
{

HookHandler._afterGetChunk_int_int += value;
HookHandler.HookGetChunk_int_int();
}
remove => HookHandler._afterGetChunk_int_int -= value;
}
public static event Delegates.GetChunk_int_int_bool_AfterArgs GetChunk_int_int_bool
{
add
{

HookHandler._afterGetChunk_int_int_bool += value;
HookHandler.HookGetChunk_int_int_bool();
}
remove => HookHandler._afterGetChunk_int_int_bool -= value;
}
public static event Delegates.ClearChunk_AfterArgs ClearChunk
{
add
{

HookHandler._afterClearChunk += value;
HookHandler.HookClearChunk();
}
remove => HookHandler._afterClearChunk -= value;
}
public static event Delegates.ClearDirtyFlag_AfterArgs ClearDirtyFlag
{
add
{

HookHandler._afterClearDirtyFlag += value;
HookHandler.HookClearDirtyFlag();
}
remove => HookHandler._afterClearDirtyFlag -= value;
}
public static event Delegates.Clear_AfterArgs Clear
{
add
{

HookHandler._afterClear += value;
HookHandler.HookClear();
}
remove => HookHandler._afterClear -= value;
}
public static event Delegates.Delete_AfterArgs Delete
{
add
{

HookHandler._afterDelete += value;
HookHandler.HookDelete();
}
remove => HookHandler._afterDelete -= value;
}
public static event Delegates.Create_AfterArgs Create
{
add
{

HookHandler._afterCreate += value;
HookHandler.HookCreate();
}
remove => HookHandler._afterCreate -= value;
}
public static event Delegates.Optimize_ColorChunk_AfterArgs Optimize_ColorChunk
{
add
{

HookHandler._afterOptimize_ColorChunk += value;
HookHandler.HookOptimize_ColorChunk();
}
remove => HookHandler._afterOptimize_ColorChunk -= value;
}
public static event Delegates.Optimize_AfterArgs Optimize
{
add
{

HookHandler._afterOptimize += value;
HookHandler.HookOptimize();
}
remove => HookHandler._afterOptimize -= value;
}
public static event Delegates.get_IsEmpty_AfterArgs get_IsEmpty
{
add
{

HookHandler._afterget_IsEmpty += value;
HookHandler.Hookget_IsEmpty();
}
remove => HookHandler._afterget_IsEmpty -= value;
}
public static event Delegates.get_NumActiveChunks_AfterArgs get_NumActiveChunks
{
add
{

HookHandler._afterget_NumActiveChunks += value;
HookHandler.Hookget_NumActiveChunks();
}
remove => HookHandler._afterget_NumActiveChunks -= value;
}
}

/// <summary>
/// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
/// </summary>
public static class WithOrig
{
public static event Delegates.Init_WithArgs Init
{
add => HookEndpointManager.Add<Delegates.Init_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Init", true), value);
remove => HookEndpointManager.Remove<Delegates.Init_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Init", true), value);
}
public static event Delegates.FindChunkAndCoordinate_WithArgs FindChunkAndCoordinate
{
add => HookEndpointManager.Add<Delegates.FindChunkAndCoordinate_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "FindChunkAndCoordinate", true), value);
remove => HookEndpointManager.Remove<Delegates.FindChunkAndCoordinate_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "FindChunkAndCoordinate", true), value);
}
public static event Delegates.GetColor_WithArgs GetColor
{
add => HookEndpointManager.Add<Delegates.GetColor_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetColor", true), value);
remove => HookEndpointManager.Remove<Delegates.GetColor_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetColor", true), value);
}
public static event Delegates.InitChunk_WithArgs InitChunk
{
add => HookEndpointManager.Add<Delegates.InitChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "InitChunk", true), value);
remove => HookEndpointManager.Remove<Delegates.InitChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "InitChunk", true), value);
}
public static event Delegates.SetColor_WithArgs SetColor
{
add => HookEndpointManager.Add<Delegates.SetColor_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "SetColor", true), value);
remove => HookEndpointManager.Remove<Delegates.SetColor_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "SetColor", true), value);
}
public static event Delegates.GetChunk_int_int_WithArgs GetChunk_int_int
{
add => HookEndpointManager.Add<Delegates.GetChunk_int_int_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk", true), value);
remove => HookEndpointManager.Remove<Delegates.GetChunk_int_int_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk", true), value);
}
public static event Delegates.GetChunk_int_int_bool_WithArgs GetChunk_int_int_bool
{
add => HookEndpointManager.Add<Delegates.GetChunk_int_int_bool_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk", true), value);
remove => HookEndpointManager.Remove<Delegates.GetChunk_int_int_bool_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "GetChunk", true), value);
}
public static event Delegates.ClearChunk_WithArgs ClearChunk
{
add => HookEndpointManager.Add<Delegates.ClearChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearChunk", true), value);
remove => HookEndpointManager.Remove<Delegates.ClearChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearChunk", true), value);
}
public static event Delegates.ClearDirtyFlag_WithArgs ClearDirtyFlag
{
add => HookEndpointManager.Add<Delegates.ClearDirtyFlag_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearDirtyFlag", true), value);
remove => HookEndpointManager.Remove<Delegates.ClearDirtyFlag_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "ClearDirtyFlag", true), value);
}
public static event Delegates.Clear_WithArgs Clear
{
add => HookEndpointManager.Add<Delegates.Clear_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Clear", true), value);
remove => HookEndpointManager.Remove<Delegates.Clear_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Clear", true), value);
}
public static event Delegates.Delete_WithArgs Delete
{
add => HookEndpointManager.Add<Delegates.Delete_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Delete", true), value);
remove => HookEndpointManager.Remove<Delegates.Delete_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Delete", true), value);
}
public static event Delegates.Create_WithArgs Create
{
add => HookEndpointManager.Add<Delegates.Create_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Create", true), value);
remove => HookEndpointManager.Remove<Delegates.Create_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Create", true), value);
}
public static event Delegates.Optimize_ColorChunk_WithArgs Optimize_ColorChunk
{
add => HookEndpointManager.Add<Delegates.Optimize_ColorChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize", true), value);
remove => HookEndpointManager.Remove<Delegates.Optimize_ColorChunk_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize", true), value);
}
public static event Delegates.Optimize_WithArgs Optimize
{
add => HookEndpointManager.Add<Delegates.Optimize_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize", true), value);
remove => HookEndpointManager.Remove<Delegates.Optimize_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "Optimize", true), value);
}
public static event Delegates.get_IsEmpty_WithArgs get_IsEmpty
{
add => HookEndpointManager.Add<Delegates.get_IsEmpty_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_IsEmpty", true), value);
remove => HookEndpointManager.Remove<Delegates.get_IsEmpty_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_IsEmpty", true), value);
}
public static event Delegates.get_NumActiveChunks_WithArgs get_NumActiveChunks
{
add => HookEndpointManager.Add<Delegates.get_NumActiveChunks_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_NumActiveChunks", true), value);
remove => HookEndpointManager.Remove<Delegates.get_NumActiveChunks_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(tk2dRuntime.TileMap.ColorChannel), "get_NumActiveChunks", true), value);
}
}

}

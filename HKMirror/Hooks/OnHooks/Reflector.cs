using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;

namespace HKMirror.Hooks.OnHooks;

/// <summary>
///     Contains different types of On Hooks for Reflector class.<br />
///     Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnReflector
{
    internal static class HookHandler
    {
        private static readonly List<string> HookedList = new();

        internal static void Hookget_AllAssemblyTypes()
        {
            if (!HookedList.Contains("get_AllAssemblyTypes"))
            {
                HookedList.Add("get_AllAssemblyTypes");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(Reflector), "get_AllAssemblyTypes", false),
                    get_AllAssemblyTypes);
            }
        }

        internal static event Delegates.get_AllAssemblyTypes_BeforeArgs _beforeget_AllAssemblyTypes;
        internal static event Delegates.get_AllAssemblyTypes_AfterArgs _afterget_AllAssemblyTypes;

        private static IEnumerable<Type> get_AllAssemblyTypes(Func<IEnumerable<Type>> orig)
        {
            if (_beforeget_AllAssemblyTypes != null)
                foreach (Delegates.get_AllAssemblyTypes_BeforeArgs toInvoke in _beforeget_AllAssemblyTypes
                             .GetInvocationList())
                    try
                    {
                        _beforeget_AllAssemblyTypes?.Invoke();
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            var retVal = orig();
            if (_afterget_AllAssemblyTypes != null)
                foreach (Delegates.get_AllAssemblyTypes_AfterArgs toInvoke in _afterget_AllAssemblyTypes
                             .GetInvocationList())
                    try
                    {
                        retVal = _afterget_AllAssemblyTypes.Invoke(retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookIgnoreAssemblyWithName()
        {
            if (!HookedList.Contains("IgnoreAssemblyWithName"))
            {
                HookedList.Add("IgnoreAssemblyWithName");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(Reflector), "IgnoreAssemblyWithName", false),
                    IgnoreAssemblyWithName);
            }
        }

        internal static event Delegates.IgnoreAssemblyWithName_BeforeArgs _beforeIgnoreAssemblyWithName;
        internal static event Delegates.IgnoreAssemblyWithName_AfterArgs _afterIgnoreAssemblyWithName;

        private static bool IgnoreAssemblyWithName(Func<string, bool> orig, string assemblyName)
        {
            Delegates.Params_IgnoreAssemblyWithName @params = new()
            {
                assemblyName = assemblyName
            };
            if (_beforeIgnoreAssemblyWithName != null)
                foreach (Delegates.IgnoreAssemblyWithName_BeforeArgs toInvoke in _beforeIgnoreAssemblyWithName
                             .GetInvocationList())
                    try
                    {
                        _beforeIgnoreAssemblyWithName?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            assemblyName = @params.assemblyName;
            var retVal = orig(assemblyName);
            if (_afterIgnoreAssemblyWithName != null)
                foreach (Delegates.IgnoreAssemblyWithName_AfterArgs toInvoke in _afterIgnoreAssemblyWithName
                             .GetInvocationList())
                    try
                    {
                        retVal = _afterIgnoreAssemblyWithName.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookGetAllAssemblyTypes()
        {
            if (!HookedList.Contains("GetAllAssemblyTypes"))
            {
                HookedList.Add("GetAllAssemblyTypes");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(Reflector), "GetAllAssemblyTypes", false),
                    GetAllAssemblyTypes);
            }
        }

        internal static event Delegates.GetAllAssemblyTypes_BeforeArgs _beforeGetAllAssemblyTypes;
        internal static event Delegates.GetAllAssemblyTypes_AfterArgs _afterGetAllAssemblyTypes;

        private static IEnumerable<Type> GetAllAssemblyTypes(Func<IEnumerable<Type>> orig)
        {
            if (_beforeGetAllAssemblyTypes != null)
                foreach (Delegates.GetAllAssemblyTypes_BeforeArgs toInvoke in _beforeGetAllAssemblyTypes
                             .GetInvocationList())
                    try
                    {
                        _beforeGetAllAssemblyTypes?.Invoke();
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            var retVal = orig();
            if (_afterGetAllAssemblyTypes != null)
                foreach (Delegates.GetAllAssemblyTypes_AfterArgs toInvoke in
                         _afterGetAllAssemblyTypes.GetInvocationList())
                    try
                    {
                        retVal = _afterGetAllAssemblyTypes.Invoke(retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }
    }

    /// <summary>
    ///     Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public delegate IEnumerable<Type> get_AllAssemblyTypes_AfterArgs(IEnumerable<Type> ret);

        public delegate void get_AllAssemblyTypes_BeforeArgs();

        public delegate IEnumerable<Type> get_AllAssemblyTypes_WithArgs(Func<IEnumerable<Type>> orig);

        public delegate IEnumerable<Type> GetAllAssemblyTypes_AfterArgs(IEnumerable<Type> ret);

        public delegate void GetAllAssemblyTypes_BeforeArgs();

        public delegate IEnumerable<Type> GetAllAssemblyTypes_WithArgs(Func<IEnumerable<Type>> orig);

        public delegate bool IgnoreAssemblyWithName_AfterArgs(Params_IgnoreAssemblyWithName args, bool ret);

        public delegate void IgnoreAssemblyWithName_BeforeArgs(Params_IgnoreAssemblyWithName args);

        public delegate bool IgnoreAssemblyWithName_WithArgs(Func<string, bool> orig, string assemblyName);

        public sealed class Params_IgnoreAssemblyWithName
        {
            public string assemblyName;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.get_AllAssemblyTypes_BeforeArgs get_AllAssemblyTypes
        {
            add
            {
                HookHandler._beforeget_AllAssemblyTypes += value;
                HookHandler.Hookget_AllAssemblyTypes();
            }
            remove => HookHandler._beforeget_AllAssemblyTypes -= value;
        }

        public static event Delegates.IgnoreAssemblyWithName_BeforeArgs IgnoreAssemblyWithName
        {
            add
            {
                HookHandler._beforeIgnoreAssemblyWithName += value;
                HookHandler.HookIgnoreAssemblyWithName();
            }
            remove => HookHandler._beforeIgnoreAssemblyWithName -= value;
        }

        public static event Delegates.GetAllAssemblyTypes_BeforeArgs GetAllAssemblyTypes
        {
            add
            {
                HookHandler._beforeGetAllAssemblyTypes += value;
                HookHandler.HookGetAllAssemblyTypes();
            }
            remove => HookHandler._beforeGetAllAssemblyTypes -= value;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.get_AllAssemblyTypes_AfterArgs get_AllAssemblyTypes
        {
            add
            {
                HookHandler._afterget_AllAssemblyTypes += value;
                HookHandler.Hookget_AllAssemblyTypes();
            }
            remove => HookHandler._afterget_AllAssemblyTypes -= value;
        }

        public static event Delegates.IgnoreAssemblyWithName_AfterArgs IgnoreAssemblyWithName
        {
            add
            {
                HookHandler._afterIgnoreAssemblyWithName += value;
                HookHandler.HookIgnoreAssemblyWithName();
            }
            remove => HookHandler._afterIgnoreAssemblyWithName -= value;
        }

        public static event Delegates.GetAllAssemblyTypes_AfterArgs GetAllAssemblyTypes
        {
            add
            {
                HookHandler._afterGetAllAssemblyTypes += value;
                HookHandler.HookGetAllAssemblyTypes();
            }
            remove => HookHandler._afterGetAllAssemblyTypes -= value;
        }
    }

    /// <summary>
    ///     Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property
    ///     getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event Delegates.get_AllAssemblyTypes_WithArgs get_AllAssemblyTypes
        {
            add => HookEndpointManager.Add<Delegates.get_AllAssemblyTypes_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "get_AllAssemblyTypes", false), value);
            remove => HookEndpointManager.Remove<Delegates.get_AllAssemblyTypes_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "get_AllAssemblyTypes", false), value);
        }

        public static event Delegates.IgnoreAssemblyWithName_WithArgs IgnoreAssemblyWithName
        {
            add => HookEndpointManager.Add<Delegates.IgnoreAssemblyWithName_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "IgnoreAssemblyWithName", false), value);
            remove => HookEndpointManager.Remove<Delegates.IgnoreAssemblyWithName_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "IgnoreAssemblyWithName", false), value);
        }

        public static event Delegates.GetAllAssemblyTypes_WithArgs GetAllAssemblyTypes
        {
            add => HookEndpointManager.Add<Delegates.GetAllAssemblyTypes_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "GetAllAssemblyTypes", false), value);
            remove => HookEndpointManager.Remove<Delegates.GetAllAssemblyTypes_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(Reflector), "GetAllAssemblyTypes", false), value);
        }
    }
}
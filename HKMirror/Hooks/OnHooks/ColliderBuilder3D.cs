using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
using tk2dRuntime.TileMap;

namespace HKMirror.Hooks.OnHooks;

/// <summary>
///     Contains different types of On Hooks for ColliderBuilder3D class.<br />
///     Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnColliderBuilder3D
{
    internal static class HookHandler
    {
        private static readonly List<string> HookedList = new();

        internal static void HookBuild()
        {
            if (!HookedList.Contains("Build"))
            {
                HookedList.Add("Build");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "Build", false), Build);
            }
        }

        internal static event Delegates.Build_BeforeArgs _beforeBuild;
        internal static event Delegates.Build_AfterArgs _afterBuild;

        private static void Build(Action<tk2dTileMap, bool> orig, tk2dTileMap tileMap, bool forceBuild)
        {
            Delegates.Params_Build @params = new()
            {
                tileMap = tileMap, forceBuild = forceBuild
            };
            if (_beforeBuild != null)
                foreach (Delegates.Build_BeforeArgs toInvoke in _beforeBuild.GetInvocationList())
                    try
                    {
                        _beforeBuild?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            tileMap = @params.tileMap;
            forceBuild = @params.forceBuild;
            orig(tileMap, forceBuild);
            if (_afterBuild != null)
                foreach (Delegates.Build_AfterArgs toInvoke in _afterBuild.GetInvocationList())
                    try
                    {
                        _afterBuild.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }

        internal static void HookBuildForChunk()
        {
            if (!HookedList.Contains("BuildForChunk"))
            {
                HookedList.Add("BuildForChunk");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildForChunk", false),
                    BuildForChunk);
            }
        }

        internal static event Delegates.BuildForChunk_BeforeArgs _beforeBuildForChunk;
        internal static event Delegates.BuildForChunk_AfterArgs _afterBuildForChunk;

        private static void BuildForChunk(Action<tk2dTileMap, SpriteChunk, int, int> orig, tk2dTileMap tileMap,
            SpriteChunk chunk, int baseX, int baseY)
        {
            Delegates.Params_BuildForChunk @params = new()
            {
                tileMap = tileMap, chunk = chunk, baseX = baseX, baseY = baseY
            };
            if (_beforeBuildForChunk != null)
                foreach (Delegates.BuildForChunk_BeforeArgs toInvoke in _beforeBuildForChunk.GetInvocationList())
                    try
                    {
                        _beforeBuildForChunk?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            tileMap = @params.tileMap;
            chunk = @params.chunk;
            baseX = @params.baseX;
            baseY = @params.baseY;
            orig(tileMap, chunk, baseX, baseY);
            if (_afterBuildForChunk != null)
                foreach (Delegates.BuildForChunk_AfterArgs toInvoke in _afterBuildForChunk.GetInvocationList())
                    try
                    {
                        _afterBuildForChunk.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }

        internal static void HookBuildLocalMeshForChunk()
        {
            if (!HookedList.Contains("BuildLocalMeshForChunk"))
            {
                HookedList.Add("BuildLocalMeshForChunk");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildLocalMeshForChunk", false),
                    BuildLocalMeshForChunk);
            }
        }

        internal static event Delegates.BuildLocalMeshForChunk_BeforeArgs _beforeBuildLocalMeshForChunk;
        internal static event Delegates.BuildLocalMeshForChunk_AfterArgs _afterBuildLocalMeshForChunk;

        private static void BuildLocalMeshForChunk(Action<tk2dTileMap, SpriteChunk, int, int, Vector3[], int[]> orig,
            tk2dTileMap tileMap, SpriteChunk chunk, int baseX, int baseY, Vector3[] vertices, int[] indices)
        {
            Delegates.Params_BuildLocalMeshForChunk @params = new()
            {
                tileMap = tileMap, chunk = chunk, baseX = baseX, baseY = baseY, vertices = vertices, indices = indices
            };
            if (_beforeBuildLocalMeshForChunk != null)
                foreach (Delegates.BuildLocalMeshForChunk_BeforeArgs toInvoke in _beforeBuildLocalMeshForChunk
                             .GetInvocationList())
                    try
                    {
                        _beforeBuildLocalMeshForChunk?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            tileMap = @params.tileMap;
            chunk = @params.chunk;
            baseX = @params.baseX;
            baseY = @params.baseY;
            vertices = @params.vertices;
            indices = @params.indices;
            orig(tileMap, chunk, baseX, baseY, vertices, indices);
            if (_afterBuildLocalMeshForChunk != null)
                foreach (Delegates.BuildLocalMeshForChunk_AfterArgs toInvoke in _afterBuildLocalMeshForChunk
                             .GetInvocationList())
                    try
                    {
                        _afterBuildLocalMeshForChunk.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }

        internal static void HookCompareWeldVertices()
        {
            if (!HookedList.Contains("CompareWeldVertices"))
            {
                HookedList.Add("CompareWeldVertices");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareWeldVertices", false),
                    CompareWeldVertices);
            }
        }

        internal static event Delegates.CompareWeldVertices_BeforeArgs _beforeCompareWeldVertices;
        internal static event Delegates.CompareWeldVertices_AfterArgs _afterCompareWeldVertices;

        private static int CompareWeldVertices(Func<Vector3, Vector3, int> orig, Vector3 a, Vector3 b)
        {
            Delegates.Params_CompareWeldVertices @params = new()
            {
                a = a, b = b
            };
            if (_beforeCompareWeldVertices != null)
                foreach (Delegates.CompareWeldVertices_BeforeArgs toInvoke in _beforeCompareWeldVertices
                             .GetInvocationList())
                    try
                    {
                        _beforeCompareWeldVertices?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            a = @params.a;
            b = @params.b;
            var retVal = orig(a, b);
            if (_afterCompareWeldVertices != null)
                foreach (Delegates.CompareWeldVertices_AfterArgs toInvoke in
                         _afterCompareWeldVertices.GetInvocationList())
                    try
                    {
                        retVal = _afterCompareWeldVertices.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookWeldVertices()
        {
            if (!HookedList.Contains("WeldVertices"))
            {
                HookedList.Add("WeldVertices");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "WeldVertices", false),
                    WeldVertices);
            }
        }

        internal static event Delegates.WeldVertices_BeforeArgs _beforeWeldVertices;
        internal static event Delegates.WeldVertices_AfterArgs _afterWeldVertices;

        private static Vector3[] WeldVertices(Func<Vector3[], int[], Vector3[]> orig, Vector3[] vertices, int[] indices)
        {
            Delegates.Params_WeldVertices @params = new()
            {
                vertices = vertices, indices = indices
            };
            if (_beforeWeldVertices != null)
                foreach (Delegates.WeldVertices_BeforeArgs toInvoke in _beforeWeldVertices.GetInvocationList())
                    try
                    {
                        _beforeWeldVertices?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            vertices = @params.vertices;
            indices = @params.indices;
            var retVal = orig(vertices, indices);
            if (_afterWeldVertices != null)
                foreach (Delegates.WeldVertices_AfterArgs toInvoke in _afterWeldVertices.GetInvocationList())
                    try
                    {
                        retVal = _afterWeldVertices.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookCompareDuplicateFaces()
        {
            if (!HookedList.Contains("CompareDuplicateFaces"))
            {
                HookedList.Add("CompareDuplicateFaces");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareDuplicateFaces", false),
                    CompareDuplicateFaces);
            }
        }

        internal static event Delegates.CompareDuplicateFaces_BeforeArgs _beforeCompareDuplicateFaces;
        internal static event Delegates.CompareDuplicateFaces_AfterArgs _afterCompareDuplicateFaces;

        private static int CompareDuplicateFaces(Func<int[], int, int, int> orig, int[] indices, int face0index,
            int face1index)
        {
            Delegates.Params_CompareDuplicateFaces @params = new()
            {
                indices = indices, face0index = face0index, face1index = face1index
            };
            if (_beforeCompareDuplicateFaces != null)
                foreach (Delegates.CompareDuplicateFaces_BeforeArgs toInvoke in _beforeCompareDuplicateFaces
                             .GetInvocationList())
                    try
                    {
                        _beforeCompareDuplicateFaces?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            indices = @params.indices;
            face0index = @params.face0index;
            face1index = @params.face1index;
            var retVal = orig(indices, face0index, face1index);
            if (_afterCompareDuplicateFaces != null)
                foreach (Delegates.CompareDuplicateFaces_AfterArgs toInvoke in _afterCompareDuplicateFaces
                             .GetInvocationList())
                    try
                    {
                        retVal = _afterCompareDuplicateFaces.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookRemoveDuplicateFaces()
        {
            if (!HookedList.Contains("RemoveDuplicateFaces"))
            {
                HookedList.Add("RemoveDuplicateFaces");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "RemoveDuplicateFaces", false),
                    RemoveDuplicateFaces);
            }
        }

        internal static event Delegates.RemoveDuplicateFaces_BeforeArgs _beforeRemoveDuplicateFaces;
        internal static event Delegates.RemoveDuplicateFaces_AfterArgs _afterRemoveDuplicateFaces;

        private static int[] RemoveDuplicateFaces(Func<int[], int[]> orig, int[] indices)
        {
            Delegates.Params_RemoveDuplicateFaces @params = new()
            {
                indices = indices
            };
            if (_beforeRemoveDuplicateFaces != null)
                foreach (Delegates.RemoveDuplicateFaces_BeforeArgs toInvoke in _beforeRemoveDuplicateFaces
                             .GetInvocationList())
                    try
                    {
                        _beforeRemoveDuplicateFaces?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            indices = @params.indices;
            var retVal = orig(indices);
            if (_afterRemoveDuplicateFaces != null)
                foreach (Delegates.RemoveDuplicateFaces_AfterArgs toInvoke in _afterRemoveDuplicateFaces
                             .GetInvocationList())
                    try
                    {
                        retVal = _afterRemoveDuplicateFaces.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }
    }

    /// <summary>
    ///     Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public delegate void Build_AfterArgs(Params_Build args);

        public delegate void Build_BeforeArgs(Params_Build args);

        public delegate void Build_WithArgs(Action<tk2dTileMap, bool> orig, tk2dTileMap tileMap, bool forceBuild);

        public delegate void BuildForChunk_AfterArgs(Params_BuildForChunk args);

        public delegate void BuildForChunk_BeforeArgs(Params_BuildForChunk args);

        public delegate void BuildForChunk_WithArgs(Action<tk2dTileMap, SpriteChunk, int, int> orig,
            tk2dTileMap tileMap, SpriteChunk chunk, int baseX, int baseY);

        public delegate void BuildLocalMeshForChunk_AfterArgs(Params_BuildLocalMeshForChunk args);

        public delegate void BuildLocalMeshForChunk_BeforeArgs(Params_BuildLocalMeshForChunk args);

        public delegate void BuildLocalMeshForChunk_WithArgs(
            Action<tk2dTileMap, SpriteChunk, int, int, Vector3[], int[]> orig, tk2dTileMap tileMap, SpriteChunk chunk,
            int baseX, int baseY, Vector3[] vertices, int[] indices);

        public delegate int CompareDuplicateFaces_AfterArgs(Params_CompareDuplicateFaces args, int ret);

        public delegate void CompareDuplicateFaces_BeforeArgs(Params_CompareDuplicateFaces args);

        public delegate int CompareDuplicateFaces_WithArgs(Func<int[], int, int, int> orig, int[] indices,
            int face0index, int face1index);

        public delegate int CompareWeldVertices_AfterArgs(Params_CompareWeldVertices args, int ret);

        public delegate void CompareWeldVertices_BeforeArgs(Params_CompareWeldVertices args);

        public delegate int CompareWeldVertices_WithArgs(Func<Vector3, Vector3, int> orig, Vector3 a, Vector3 b);

        public delegate int[] RemoveDuplicateFaces_AfterArgs(Params_RemoveDuplicateFaces args, int[] ret);

        public delegate void RemoveDuplicateFaces_BeforeArgs(Params_RemoveDuplicateFaces args);

        public delegate int[] RemoveDuplicateFaces_WithArgs(Func<int[], int[]> orig, int[] indices);

        public delegate Vector3[] WeldVertices_AfterArgs(Params_WeldVertices args, Vector3[] ret);

        public delegate void WeldVertices_BeforeArgs(Params_WeldVertices args);

        public delegate Vector3[] WeldVertices_WithArgs(Func<Vector3[], int[], Vector3[]> orig, Vector3[] vertices,
            int[] indices);

        public sealed class Params_Build
        {
            public bool forceBuild;
            public tk2dTileMap tileMap;
        }

        public sealed class Params_BuildForChunk
        {
            public int baseX;
            public int baseY;
            public SpriteChunk chunk;
            public tk2dTileMap tileMap;
        }

        public sealed class Params_BuildLocalMeshForChunk
        {
            public int baseX;
            public int baseY;
            public SpriteChunk chunk;
            public int[] indices;
            public tk2dTileMap tileMap;
            public Vector3[] vertices;
        }

        public sealed class Params_CompareWeldVertices
        {
            public Vector3 a;
            public Vector3 b;
        }

        public sealed class Params_WeldVertices
        {
            public int[] indices;
            public Vector3[] vertices;
        }

        public sealed class Params_CompareDuplicateFaces
        {
            public int face0index;
            public int face1index;
            public int[] indices;
        }

        public sealed class Params_RemoveDuplicateFaces
        {
            public int[] indices;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.Build_BeforeArgs Build
        {
            add
            {
                HookHandler._beforeBuild += value;
                HookHandler.HookBuild();
            }
            remove => HookHandler._beforeBuild -= value;
        }

        public static event Delegates.BuildForChunk_BeforeArgs BuildForChunk
        {
            add
            {
                HookHandler._beforeBuildForChunk += value;
                HookHandler.HookBuildForChunk();
            }
            remove => HookHandler._beforeBuildForChunk -= value;
        }

        public static event Delegates.BuildLocalMeshForChunk_BeforeArgs BuildLocalMeshForChunk
        {
            add
            {
                HookHandler._beforeBuildLocalMeshForChunk += value;
                HookHandler.HookBuildLocalMeshForChunk();
            }
            remove => HookHandler._beforeBuildLocalMeshForChunk -= value;
        }

        public static event Delegates.CompareWeldVertices_BeforeArgs CompareWeldVertices
        {
            add
            {
                HookHandler._beforeCompareWeldVertices += value;
                HookHandler.HookCompareWeldVertices();
            }
            remove => HookHandler._beforeCompareWeldVertices -= value;
        }

        public static event Delegates.WeldVertices_BeforeArgs WeldVertices
        {
            add
            {
                HookHandler._beforeWeldVertices += value;
                HookHandler.HookWeldVertices();
            }
            remove => HookHandler._beforeWeldVertices -= value;
        }

        public static event Delegates.CompareDuplicateFaces_BeforeArgs CompareDuplicateFaces
        {
            add
            {
                HookHandler._beforeCompareDuplicateFaces += value;
                HookHandler.HookCompareDuplicateFaces();
            }
            remove => HookHandler._beforeCompareDuplicateFaces -= value;
        }

        public static event Delegates.RemoveDuplicateFaces_BeforeArgs RemoveDuplicateFaces
        {
            add
            {
                HookHandler._beforeRemoveDuplicateFaces += value;
                HookHandler.HookRemoveDuplicateFaces();
            }
            remove => HookHandler._beforeRemoveDuplicateFaces -= value;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.Build_AfterArgs Build
        {
            add
            {
                HookHandler._afterBuild += value;
                HookHandler.HookBuild();
            }
            remove => HookHandler._afterBuild -= value;
        }

        public static event Delegates.BuildForChunk_AfterArgs BuildForChunk
        {
            add
            {
                HookHandler._afterBuildForChunk += value;
                HookHandler.HookBuildForChunk();
            }
            remove => HookHandler._afterBuildForChunk -= value;
        }

        public static event Delegates.BuildLocalMeshForChunk_AfterArgs BuildLocalMeshForChunk
        {
            add
            {
                HookHandler._afterBuildLocalMeshForChunk += value;
                HookHandler.HookBuildLocalMeshForChunk();
            }
            remove => HookHandler._afterBuildLocalMeshForChunk -= value;
        }

        public static event Delegates.CompareWeldVertices_AfterArgs CompareWeldVertices
        {
            add
            {
                HookHandler._afterCompareWeldVertices += value;
                HookHandler.HookCompareWeldVertices();
            }
            remove => HookHandler._afterCompareWeldVertices -= value;
        }

        public static event Delegates.WeldVertices_AfterArgs WeldVertices
        {
            add
            {
                HookHandler._afterWeldVertices += value;
                HookHandler.HookWeldVertices();
            }
            remove => HookHandler._afterWeldVertices -= value;
        }

        public static event Delegates.CompareDuplicateFaces_AfterArgs CompareDuplicateFaces
        {
            add
            {
                HookHandler._afterCompareDuplicateFaces += value;
                HookHandler.HookCompareDuplicateFaces();
            }
            remove => HookHandler._afterCompareDuplicateFaces -= value;
        }

        public static event Delegates.RemoveDuplicateFaces_AfterArgs RemoveDuplicateFaces
        {
            add
            {
                HookHandler._afterRemoveDuplicateFaces += value;
                HookHandler.HookRemoveDuplicateFaces();
            }
            remove => HookHandler._afterRemoveDuplicateFaces -= value;
        }
    }

    /// <summary>
    ///     Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property
    ///     getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event Delegates.Build_WithArgs Build
        {
            add => HookEndpointManager.Add<Delegates.Build_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "Build", false), value);
            remove => HookEndpointManager.Remove<Delegates.Build_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "Build", false), value);
        }

        public static event Delegates.BuildForChunk_WithArgs BuildForChunk
        {
            add => HookEndpointManager.Add<Delegates.BuildForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildForChunk", false), value);
            remove => HookEndpointManager.Remove<Delegates.BuildForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildForChunk", false), value);
        }

        public static event Delegates.BuildLocalMeshForChunk_WithArgs BuildLocalMeshForChunk
        {
            add => HookEndpointManager.Add<Delegates.BuildLocalMeshForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildLocalMeshForChunk", false), value);
            remove => HookEndpointManager.Remove<Delegates.BuildLocalMeshForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "BuildLocalMeshForChunk", false), value);
        }

        public static event Delegates.CompareWeldVertices_WithArgs CompareWeldVertices
        {
            add => HookEndpointManager.Add<Delegates.CompareWeldVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareWeldVertices", false), value);
            remove => HookEndpointManager.Remove<Delegates.CompareWeldVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareWeldVertices", false), value);
        }

        public static event Delegates.WeldVertices_WithArgs WeldVertices
        {
            add => HookEndpointManager.Add<Delegates.WeldVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "WeldVertices", false), value);
            remove => HookEndpointManager.Remove<Delegates.WeldVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "WeldVertices", false), value);
        }

        public static event Delegates.CompareDuplicateFaces_WithArgs CompareDuplicateFaces
        {
            add => HookEndpointManager.Add<Delegates.CompareDuplicateFaces_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareDuplicateFaces", false), value);
            remove => HookEndpointManager.Remove<Delegates.CompareDuplicateFaces_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "CompareDuplicateFaces", false), value);
        }

        public static event Delegates.RemoveDuplicateFaces_WithArgs RemoveDuplicateFaces
        {
            add => HookEndpointManager.Add<Delegates.RemoveDuplicateFaces_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "RemoveDuplicateFaces", false), value);
            remove => HookEndpointManager.Remove<Delegates.RemoveDuplicateFaces_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(ColliderBuilder3D), "RemoveDuplicateFaces", false), value);
        }
    }
}
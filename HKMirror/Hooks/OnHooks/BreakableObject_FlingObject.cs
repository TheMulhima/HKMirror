using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;

namespace HKMirror.Hooks.OnHooks;

/// <summary>
///     Contains different types of On Hooks for BreakableObject_FlingObject class.<br />
///     Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnBreakableObject_FlingObject
{
    internal static class HookHandler
    {
        private static readonly List<string> HookedList = new();

        internal static void HookFling()
        {
            if (!HookedList.Contains("Fling"))
            {
                HookedList.Add("Fling");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(BreakableObject.FlingObject), "Fling"), Fling);
            }
        }

        internal static event Delegates.Fling_BeforeArgs _beforeFling;
        internal static event Delegates.Fling_AfterArgs _afterFling;

        private static void Fling(Action<BreakableObject.FlingObject, Vector3> orig, BreakableObject.FlingObject self,
            Vector3 origin)
        {
            Delegates.Params_Fling @params = new()
            {
                self = self, origin = origin
            };
            if (_beforeFling != null)
                foreach (Delegates.Fling_BeforeArgs toInvoke in _beforeFling.GetInvocationList())
                    try
                    {
                        _beforeFling?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            self = @params.self;
            origin = @params.origin;
            orig(self, origin);
            if (_afterFling != null)
                foreach (Delegates.Fling_AfterArgs toInvoke in _afterFling.GetInvocationList())
                    try
                    {
                        _afterFling.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }
    }

    /// <summary>
    ///     Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public delegate void Fling_AfterArgs(Params_Fling args);

        public delegate void Fling_BeforeArgs(Params_Fling args);

        public delegate void Fling_WithArgs(Action<BreakableObject.FlingObject, Vector3> orig,
            BreakableObject.FlingObject self, Vector3 origin);

        public sealed class Params_Fling
        {
            public Vector3 origin;
            public BreakableObject.FlingObject self;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.Fling_BeforeArgs Fling
        {
            add
            {
                HookHandler._beforeFling += value;
                HookHandler.HookFling();
            }
            remove => HookHandler._beforeFling -= value;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.Fling_AfterArgs Fling
        {
            add
            {
                HookHandler._afterFling += value;
                HookHandler.HookFling();
            }
            remove => HookHandler._afterFling -= value;
        }
    }

    /// <summary>
    ///     Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property
    ///     getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event Delegates.Fling_WithArgs Fling
        {
            add => HookEndpointManager.Add<Delegates.Fling_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(BreakableObject.FlingObject), "Fling"), value);
            remove => HookEndpointManager.Remove<Delegates.Fling_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(BreakableObject.FlingObject), "Fling"), value);
        }
    }
}
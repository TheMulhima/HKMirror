using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;

namespace HKMirror.Hooks.OnHooks;

/// <summary>
/// Contains different types of On Hooks for TMP_TextInfo class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnTMP_TextInfo
{
    internal static class HookHandler
    {
        private static List<string> HookedList = new List<string>();

        internal static void HookClear()
        {
            if (!HookedList.Contains("Clear"))
            {
                HookedList.Add("Clear");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "Clear", true), Clear);
            }
        }

        internal static event Delegates.Clear_BeforeArgs _beforeClear;
        internal static event Delegates.Clear_AfterArgs _afterClear;

        private static void Clear(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self)
        {
            Delegates.Params_Clear @params = new()
            {
                self = self
            };
            if (_beforeClear != null)
            {
                foreach (Delegates.Clear_BeforeArgs toInvoke in _beforeClear.GetInvocationList())
                {
                    try
                    {
                        _beforeClear?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            orig(self);
            if (_afterClear != null)
            {
                foreach (Delegates.Clear_AfterArgs toInvoke in _afterClear.GetInvocationList())
                {
                    try
                    {
                        _afterClear.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookClearMeshInfo()
        {
            if (!HookedList.Contains("ClearMeshInfo"))
            {
                HookedList.Add("ClearMeshInfo");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearMeshInfo", true),
                    ClearMeshInfo);
            }
        }

        internal static event Delegates.ClearMeshInfo_BeforeArgs _beforeClearMeshInfo;
        internal static event Delegates.ClearMeshInfo_AfterArgs _afterClearMeshInfo;

        private static void ClearMeshInfo(Action<TMPro.TMP_TextInfo, bool> orig, TMPro.TMP_TextInfo self,
            bool updateMesh)
        {
            Delegates.Params_ClearMeshInfo @params = new()
            {
                self = self, updateMesh = updateMesh
            };
            if (_beforeClearMeshInfo != null)
            {
                foreach (Delegates.ClearMeshInfo_BeforeArgs toInvoke in _beforeClearMeshInfo.GetInvocationList())
                {
                    try
                    {
                        _beforeClearMeshInfo?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            updateMesh = @params.updateMesh;
            orig(self, updateMesh);
            if (_afterClearMeshInfo != null)
            {
                foreach (Delegates.ClearMeshInfo_AfterArgs toInvoke in _afterClearMeshInfo.GetInvocationList())
                {
                    try
                    {
                        _afterClearMeshInfo.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookClearAllMeshInfo()
        {
            if (!HookedList.Contains("ClearAllMeshInfo"))
            {
                HookedList.Add("ClearAllMeshInfo");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearAllMeshInfo", true),
                    ClearAllMeshInfo);
            }
        }

        internal static event Delegates.ClearAllMeshInfo_BeforeArgs _beforeClearAllMeshInfo;
        internal static event Delegates.ClearAllMeshInfo_AfterArgs _afterClearAllMeshInfo;

        private static void ClearAllMeshInfo(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self)
        {
            Delegates.Params_ClearAllMeshInfo @params = new()
            {
                self = self
            };
            if (_beforeClearAllMeshInfo != null)
            {
                foreach (Delegates.ClearAllMeshInfo_BeforeArgs toInvoke in _beforeClearAllMeshInfo.GetInvocationList())
                {
                    try
                    {
                        _beforeClearAllMeshInfo?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            orig(self);
            if (_afterClearAllMeshInfo != null)
            {
                foreach (Delegates.ClearAllMeshInfo_AfterArgs toInvoke in _afterClearAllMeshInfo.GetInvocationList())
                {
                    try
                    {
                        _afterClearAllMeshInfo.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookResetVertexLayout()
        {
            if (!HookedList.Contains("ResetVertexLayout"))
            {
                HookedList.Add("ResetVertexLayout");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ResetVertexLayout", true),
                    ResetVertexLayout);
            }
        }

        internal static event Delegates.ResetVertexLayout_BeforeArgs _beforeResetVertexLayout;
        internal static event Delegates.ResetVertexLayout_AfterArgs _afterResetVertexLayout;

        private static void ResetVertexLayout(Action<TMPro.TMP_TextInfo, bool> orig, TMPro.TMP_TextInfo self,
            bool isVolumetric)
        {
            Delegates.Params_ResetVertexLayout @params = new()
            {
                self = self, isVolumetric = isVolumetric
            };
            if (_beforeResetVertexLayout != null)
            {
                foreach (Delegates.ResetVertexLayout_BeforeArgs toInvoke in
                         _beforeResetVertexLayout.GetInvocationList())
                {
                    try
                    {
                        _beforeResetVertexLayout?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            isVolumetric = @params.isVolumetric;
            orig(self, isVolumetric);
            if (_afterResetVertexLayout != null)
            {
                foreach (Delegates.ResetVertexLayout_AfterArgs toInvoke in _afterResetVertexLayout.GetInvocationList())
                {
                    try
                    {
                        _afterResetVertexLayout.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookClearUnusedVertices()
        {
            if (!HookedList.Contains("ClearUnusedVertices"))
            {
                HookedList.Add("ClearUnusedVertices");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearUnusedVertices", true),
                    ClearUnusedVertices);
            }
        }

        internal static event Delegates.ClearUnusedVertices_BeforeArgs _beforeClearUnusedVertices;
        internal static event Delegates.ClearUnusedVertices_AfterArgs _afterClearUnusedVertices;

        private static void ClearUnusedVertices(Action<TMPro.TMP_TextInfo, TMPro.MaterialReference[]> orig,
            TMPro.TMP_TextInfo self, TMPro.MaterialReference[] materials)
        {
            Delegates.Params_ClearUnusedVertices @params = new()
            {
                self = self, materials = materials
            };
            if (_beforeClearUnusedVertices != null)
            {
                foreach (Delegates.ClearUnusedVertices_BeforeArgs toInvoke in _beforeClearUnusedVertices
                             .GetInvocationList())
                {
                    try
                    {
                        _beforeClearUnusedVertices?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            materials = @params.materials;
            orig(self, materials);
            if (_afterClearUnusedVertices != null)
            {
                foreach (Delegates.ClearUnusedVertices_AfterArgs toInvoke in
                         _afterClearUnusedVertices.GetInvocationList())
                {
                    try
                    {
                        _afterClearUnusedVertices.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookClearLineInfo()
        {
            if (!HookedList.Contains("ClearLineInfo"))
            {
                HookedList.Add("ClearLineInfo");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearLineInfo", true),
                    ClearLineInfo);
            }
        }

        internal static event Delegates.ClearLineInfo_BeforeArgs _beforeClearLineInfo;
        internal static event Delegates.ClearLineInfo_AfterArgs _afterClearLineInfo;

        private static void ClearLineInfo(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self)
        {
            Delegates.Params_ClearLineInfo @params = new()
            {
                self = self
            };
            if (_beforeClearLineInfo != null)
            {
                foreach (Delegates.ClearLineInfo_BeforeArgs toInvoke in _beforeClearLineInfo.GetInvocationList())
                {
                    try
                    {
                        _beforeClearLineInfo?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            orig(self);
            if (_afterClearLineInfo != null)
            {
                foreach (Delegates.ClearLineInfo_AfterArgs toInvoke in _afterClearLineInfo.GetInvocationList())
                {
                    try
                    {
                        _afterClearLineInfo.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }
        }

        internal static void HookCopyMeshInfoVertexData()
        {
            if (!HookedList.Contains("CopyMeshInfoVertexData"))
            {
                HookedList.Add("CopyMeshInfoVertexData");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "CopyMeshInfoVertexData", true),
                    CopyMeshInfoVertexData);
            }
        }

        internal static event Delegates.CopyMeshInfoVertexData_BeforeArgs _beforeCopyMeshInfoVertexData;
        internal static event Delegates.CopyMeshInfoVertexData_AfterArgs _afterCopyMeshInfoVertexData;

        private static TMPro.TMP_MeshInfo[] CopyMeshInfoVertexData(Func<TMPro.TMP_TextInfo, TMPro.TMP_MeshInfo[]> orig,
            TMPro.TMP_TextInfo self)
        {
            Delegates.Params_CopyMeshInfoVertexData @params = new()
            {
                self = self
            };
            if (_beforeCopyMeshInfoVertexData != null)
            {
                foreach (Delegates.CopyMeshInfoVertexData_BeforeArgs toInvoke in _beforeCopyMeshInfoVertexData
                             .GetInvocationList())
                {
                    try
                    {
                        _beforeCopyMeshInfoVertexData?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            self = @params.self;
            var retVal = orig(self);
            if (_afterCopyMeshInfoVertexData != null)
            {
                foreach (Delegates.CopyMeshInfoVertexData_AfterArgs toInvoke in _afterCopyMeshInfoVertexData
                             .GetInvocationList())
                {
                    try
                    {
                        retVal = _afterCopyMeshInfoVertexData.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
                }
            }

            return retVal;
        }
    }

    /// <summary>
    /// Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public sealed class Params_Clear
        {
            public TMPro.TMP_TextInfo self;
        }

        public delegate void Clear_BeforeArgs(Params_Clear args);

        public delegate void Clear_AfterArgs(Params_Clear args);

        public delegate void Clear_WithArgs(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self);

        public sealed class Params_ClearMeshInfo
        {
            public TMPro.TMP_TextInfo self;
            public bool updateMesh;
        }

        public delegate void ClearMeshInfo_BeforeArgs(Params_ClearMeshInfo args);

        public delegate void ClearMeshInfo_AfterArgs(Params_ClearMeshInfo args);

        public delegate void ClearMeshInfo_WithArgs(Action<TMPro.TMP_TextInfo, bool> orig, TMPro.TMP_TextInfo self,
            bool updateMesh);

        public sealed class Params_ClearAllMeshInfo
        {
            public TMPro.TMP_TextInfo self;
        }

        public delegate void ClearAllMeshInfo_BeforeArgs(Params_ClearAllMeshInfo args);

        public delegate void ClearAllMeshInfo_AfterArgs(Params_ClearAllMeshInfo args);

        public delegate void ClearAllMeshInfo_WithArgs(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self);

        public sealed class Params_ResetVertexLayout
        {
            public TMPro.TMP_TextInfo self;
            public bool isVolumetric;
        }

        public delegate void ResetVertexLayout_BeforeArgs(Params_ResetVertexLayout args);

        public delegate void ResetVertexLayout_AfterArgs(Params_ResetVertexLayout args);

        public delegate void ResetVertexLayout_WithArgs(Action<TMPro.TMP_TextInfo, bool> orig, TMPro.TMP_TextInfo self,
            bool isVolumetric);

        public sealed class Params_ClearUnusedVertices
        {
            public TMPro.TMP_TextInfo self;
            public TMPro.MaterialReference[] materials;
        }

        public delegate void ClearUnusedVertices_BeforeArgs(Params_ClearUnusedVertices args);

        public delegate void ClearUnusedVertices_AfterArgs(Params_ClearUnusedVertices args);

        public delegate void ClearUnusedVertices_WithArgs(Action<TMPro.TMP_TextInfo, TMPro.MaterialReference[]> orig,
            TMPro.TMP_TextInfo self, TMPro.MaterialReference[] materials);

        public sealed class Params_ClearLineInfo
        {
            public TMPro.TMP_TextInfo self;
        }

        public delegate void ClearLineInfo_BeforeArgs(Params_ClearLineInfo args);

        public delegate void ClearLineInfo_AfterArgs(Params_ClearLineInfo args);

        public delegate void ClearLineInfo_WithArgs(Action<TMPro.TMP_TextInfo> orig, TMPro.TMP_TextInfo self);

        public sealed class Params_CopyMeshInfoVertexData
        {
            public TMPro.TMP_TextInfo self;
        }

        public delegate void CopyMeshInfoVertexData_BeforeArgs(Params_CopyMeshInfoVertexData args);

        public delegate TMPro.TMP_MeshInfo[] CopyMeshInfoVertexData_AfterArgs(Params_CopyMeshInfoVertexData args,
            TMPro.TMP_MeshInfo[] ret);

        public delegate TMPro.TMP_MeshInfo[] CopyMeshInfoVertexData_WithArgs(
            Func<TMPro.TMP_TextInfo, TMPro.TMP_MeshInfo[]> orig, TMPro.TMP_TextInfo self);
    }

    /// <summary>
    /// Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.Clear_BeforeArgs Clear
        {
            add
            {
                HookHandler._beforeClear += value;
                HookHandler.HookClear();
            }
            remove => HookHandler._beforeClear -= value;
        }

        public static event Delegates.ClearMeshInfo_BeforeArgs ClearMeshInfo
        {
            add
            {
                HookHandler._beforeClearMeshInfo += value;
                HookHandler.HookClearMeshInfo();
            }
            remove => HookHandler._beforeClearMeshInfo -= value;
        }

        public static event Delegates.ClearAllMeshInfo_BeforeArgs ClearAllMeshInfo
        {
            add
            {
                HookHandler._beforeClearAllMeshInfo += value;
                HookHandler.HookClearAllMeshInfo();
            }
            remove => HookHandler._beforeClearAllMeshInfo -= value;
        }

        public static event Delegates.ResetVertexLayout_BeforeArgs ResetVertexLayout
        {
            add
            {
                HookHandler._beforeResetVertexLayout += value;
                HookHandler.HookResetVertexLayout();
            }
            remove => HookHandler._beforeResetVertexLayout -= value;
        }

        public static event Delegates.ClearUnusedVertices_BeforeArgs ClearUnusedVertices
        {
            add
            {
                HookHandler._beforeClearUnusedVertices += value;
                HookHandler.HookClearUnusedVertices();
            }
            remove => HookHandler._beforeClearUnusedVertices -= value;
        }

        public static event Delegates.ClearLineInfo_BeforeArgs ClearLineInfo
        {
            add
            {
                HookHandler._beforeClearLineInfo += value;
                HookHandler.HookClearLineInfo();
            }
            remove => HookHandler._beforeClearLineInfo -= value;
        }

        public static event Delegates.CopyMeshInfoVertexData_BeforeArgs CopyMeshInfoVertexData
        {
            add
            {
                HookHandler._beforeCopyMeshInfoVertexData += value;
                HookHandler.HookCopyMeshInfoVertexData();
            }
            remove => HookHandler._beforeCopyMeshInfoVertexData -= value;
        }
    }

    /// <summary>
    /// Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.Clear_AfterArgs Clear
        {
            add
            {
                HookHandler._afterClear += value;
                HookHandler.HookClear();
            }
            remove => HookHandler._afterClear -= value;
        }

        public static event Delegates.ClearMeshInfo_AfterArgs ClearMeshInfo
        {
            add
            {
                HookHandler._afterClearMeshInfo += value;
                HookHandler.HookClearMeshInfo();
            }
            remove => HookHandler._afterClearMeshInfo -= value;
        }

        public static event Delegates.ClearAllMeshInfo_AfterArgs ClearAllMeshInfo
        {
            add
            {
                HookHandler._afterClearAllMeshInfo += value;
                HookHandler.HookClearAllMeshInfo();
            }
            remove => HookHandler._afterClearAllMeshInfo -= value;
        }

        public static event Delegates.ResetVertexLayout_AfterArgs ResetVertexLayout
        {
            add
            {
                HookHandler._afterResetVertexLayout += value;
                HookHandler.HookResetVertexLayout();
            }
            remove => HookHandler._afterResetVertexLayout -= value;
        }

        public static event Delegates.ClearUnusedVertices_AfterArgs ClearUnusedVertices
        {
            add
            {
                HookHandler._afterClearUnusedVertices += value;
                HookHandler.HookClearUnusedVertices();
            }
            remove => HookHandler._afterClearUnusedVertices -= value;
        }

        public static event Delegates.ClearLineInfo_AfterArgs ClearLineInfo
        {
            add
            {
                HookHandler._afterClearLineInfo += value;
                HookHandler.HookClearLineInfo();
            }
            remove => HookHandler._afterClearLineInfo -= value;
        }

        public static event Delegates.CopyMeshInfoVertexData_AfterArgs CopyMeshInfoVertexData
        {
            add
            {
                HookHandler._afterCopyMeshInfoVertexData += value;
                HookHandler.HookCopyMeshInfoVertexData();
            }
            remove => HookHandler._afterCopyMeshInfoVertexData -= value;
        }
    }

    /// <summary>
    /// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event Delegates.Clear_WithArgs Clear
        {
            add => HookEndpointManager.Add<Delegates.Clear_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "Clear", true), value);
            remove => HookEndpointManager.Remove<Delegates.Clear_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "Clear", true), value);
        }

        public static event Delegates.ClearMeshInfo_WithArgs ClearMeshInfo
        {
            add => HookEndpointManager.Add<Delegates.ClearMeshInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearMeshInfo", true), value);
            remove => HookEndpointManager.Remove<Delegates.ClearMeshInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearMeshInfo", true), value);
        }

        public static event Delegates.ClearAllMeshInfo_WithArgs ClearAllMeshInfo
        {
            add => HookEndpointManager.Add<Delegates.ClearAllMeshInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearAllMeshInfo", true), value);
            remove => HookEndpointManager.Remove<Delegates.ClearAllMeshInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearAllMeshInfo", true), value);
        }

        public static event Delegates.ResetVertexLayout_WithArgs ResetVertexLayout
        {
            add => HookEndpointManager.Add<Delegates.ResetVertexLayout_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ResetVertexLayout", true), value);
            remove => HookEndpointManager.Remove<Delegates.ResetVertexLayout_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ResetVertexLayout", true), value);
        }

        public static event Delegates.ClearUnusedVertices_WithArgs ClearUnusedVertices
        {
            add => HookEndpointManager.Add<Delegates.ClearUnusedVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearUnusedVertices", true), value);
            remove => HookEndpointManager.Remove<Delegates.ClearUnusedVertices_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearUnusedVertices", true), value);
        }

        public static event Delegates.ClearLineInfo_WithArgs ClearLineInfo
        {
            add => HookEndpointManager.Add<Delegates.ClearLineInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearLineInfo", true), value);
            remove => HookEndpointManager.Remove<Delegates.ClearLineInfo_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "ClearLineInfo", true), value);
        }

        public static event Delegates.CopyMeshInfoVertexData_WithArgs CopyMeshInfoVertexData
        {
            add => HookEndpointManager.Add<Delegates.CopyMeshInfoVertexData_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "CopyMeshInfoVertexData", true), value);
            remove => HookEndpointManager.Remove<Delegates.CopyMeshInfoVertexData_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(TMPro.TMP_TextInfo), "CopyMeshInfoVertexData", true), value);
        }
    }
}
using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
using tk2dRuntime.TileMap;

namespace HKMirror.Hooks.OnHooks;

/// <summary>
///     Contains different types of On Hooks for RenderMeshBuilder class.<br />
///     Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnRenderMeshBuilder
{
    internal static class HookHandler
    {
        private static readonly List<string> HookedList = new();

        internal static void HookBuildForChunk()
        {
            if (!HookedList.Contains("BuildForChunk"))
            {
                HookedList.Add("BuildForChunk");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "BuildForChunk", false),
                    BuildForChunk);
            }
        }

        internal static event Delegates.BuildForChunk_BeforeArgs _beforeBuildForChunk;
        internal static event Delegates.BuildForChunk_AfterArgs _afterBuildForChunk;

        private static void BuildForChunk(Action<tk2dTileMap, SpriteChunk, ColorChunk, bool, bool, int, int> orig,
            tk2dTileMap tileMap, SpriteChunk chunk, ColorChunk colorChunk, bool useColor, bool skipPrefabs, int baseX,
            int baseY)
        {
            Delegates.Params_BuildForChunk @params = new()
            {
                tileMap = tileMap, chunk = chunk, colorChunk = colorChunk, useColor = useColor,
                skipPrefabs = skipPrefabs, baseX = baseX, baseY = baseY
            };
            if (_beforeBuildForChunk != null)
                foreach (Delegates.BuildForChunk_BeforeArgs toInvoke in _beforeBuildForChunk.GetInvocationList())
                    try
                    {
                        _beforeBuildForChunk?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            tileMap = @params.tileMap;
            chunk = @params.chunk;
            colorChunk = @params.colorChunk;
            useColor = @params.useColor;
            skipPrefabs = @params.skipPrefabs;
            baseX = @params.baseX;
            baseY = @params.baseY;
            orig(tileMap, chunk, colorChunk, useColor, skipPrefabs, baseX, baseY);
            if (_afterBuildForChunk != null)
                foreach (Delegates.BuildForChunk_AfterArgs toInvoke in _afterBuildForChunk.GetInvocationList())
                    try
                    {
                        _afterBuildForChunk.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }

        internal static void HookBuild()
        {
            if (!HookedList.Contains("Build"))
            {
                HookedList.Add("Build");
                new Hook(ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "Build", false), Build);
            }
        }

        internal static event Delegates.Build_BeforeArgs _beforeBuild;
        internal static event Delegates.Build_AfterArgs _afterBuild;

        private static void Build(Action<tk2dTileMap, bool, bool> orig, tk2dTileMap tileMap, bool editMode,
            bool forceBuild)
        {
            Delegates.Params_Build @params = new()
            {
                tileMap = tileMap, editMode = editMode, forceBuild = forceBuild
            };
            if (_beforeBuild != null)
                foreach (Delegates.Build_BeforeArgs toInvoke in _beforeBuild.GetInvocationList())
                    try
                    {
                        _beforeBuild?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            tileMap = @params.tileMap;
            editMode = @params.editMode;
            forceBuild = @params.forceBuild;
            orig(tileMap, editMode, forceBuild);
            if (_afterBuild != null)
                foreach (Delegates.Build_AfterArgs toInvoke in _afterBuild.GetInvocationList())
                    try
                    {
                        _afterBuild.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }
    }

    /// <summary>
    ///     Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public delegate void Build_AfterArgs(Params_Build args);

        public delegate void Build_BeforeArgs(Params_Build args);

        public delegate void Build_WithArgs(Action<tk2dTileMap, bool, bool> orig, tk2dTileMap tileMap, bool editMode,
            bool forceBuild);

        public delegate void BuildForChunk_AfterArgs(Params_BuildForChunk args);

        public delegate void BuildForChunk_BeforeArgs(Params_BuildForChunk args);

        public delegate void BuildForChunk_WithArgs(
            Action<tk2dTileMap, SpriteChunk, ColorChunk, bool, bool, int, int> orig, tk2dTileMap tileMap,
            SpriteChunk chunk, ColorChunk colorChunk, bool useColor, bool skipPrefabs, int baseX, int baseY);

        public sealed class Params_BuildForChunk
        {
            public int baseX;
            public int baseY;
            public SpriteChunk chunk;
            public ColorChunk colorChunk;
            public bool skipPrefabs;
            public tk2dTileMap tileMap;
            public bool useColor;
        }

        public sealed class Params_Build
        {
            public bool editMode;
            public bool forceBuild;
            public tk2dTileMap tileMap;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.BuildForChunk_BeforeArgs BuildForChunk
        {
            add
            {
                HookHandler._beforeBuildForChunk += value;
                HookHandler.HookBuildForChunk();
            }
            remove => HookHandler._beforeBuildForChunk -= value;
        }

        public static event Delegates.Build_BeforeArgs Build
        {
            add
            {
                HookHandler._beforeBuild += value;
                HookHandler.HookBuild();
            }
            remove => HookHandler._beforeBuild -= value;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.BuildForChunk_AfterArgs BuildForChunk
        {
            add
            {
                HookHandler._afterBuildForChunk += value;
                HookHandler.HookBuildForChunk();
            }
            remove => HookHandler._afterBuildForChunk -= value;
        }

        public static event Delegates.Build_AfterArgs Build
        {
            add
            {
                HookHandler._afterBuild += value;
                HookHandler.HookBuild();
            }
            remove => HookHandler._afterBuild -= value;
        }
    }

    /// <summary>
    ///     Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property
    ///     getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event Delegates.BuildForChunk_WithArgs BuildForChunk
        {
            add => HookEndpointManager.Add<Delegates.BuildForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "BuildForChunk", false), value);
            remove => HookEndpointManager.Remove<Delegates.BuildForChunk_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "BuildForChunk", false), value);
        }

        public static event Delegates.Build_WithArgs Build
        {
            add => HookEndpointManager.Add<Delegates.Build_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "Build", false), value);
            remove => HookEndpointManager.Remove<Delegates.Build_WithArgs>(
                ReflectionHelper.GetMethodInfo(typeof(RenderMeshBuilder), "Build", false), value);
        }
    }
}
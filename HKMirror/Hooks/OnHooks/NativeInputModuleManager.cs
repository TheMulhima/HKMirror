using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
namespace HKMirror.Hooks.OnHooks;
/// <summary>
/// Contains different types of On Hooks for NativeInputModuleManager class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnNativeInputModuleManager
{
internal static class HookHandler
{
private static List<string> HookedList = new List<string>();
internal static void Hookget_IsUsed()
{
if (!HookedList.Contains("get_IsUsed"))
{
HookedList.Add("get_IsUsed");
new Hook(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsUsed", false), get_IsUsed);

}
}
internal static event Delegates.get_IsUsed_BeforeArgs _beforeget_IsUsed;
internal static event Delegates.get_IsUsed_AfterArgs _afterget_IsUsed;
private static bool get_IsUsed(Func<bool> orig)
{
if (_beforeget_IsUsed != null)
{
foreach (Delegates.get_IsUsed_BeforeArgs toInvoke in _beforeget_IsUsed.GetInvocationList())
{
try
{
_beforeget_IsUsed?.Invoke();
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
var retVal = orig();
if (_afterget_IsUsed != null)
{
foreach (Delegates.get_IsUsed_AfterArgs toInvoke in _afterget_IsUsed.GetInvocationList())
{
try
{
retVal = _afterget_IsUsed.Invoke(retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void Hookset_IsUsed()
{
if (!HookedList.Contains("set_IsUsed"))
{
HookedList.Add("set_IsUsed");
new Hook(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "set_IsUsed", false), set_IsUsed);

}
}
internal static event Delegates.set_IsUsed_BeforeArgs _beforeset_IsUsed;
internal static event Delegates.set_IsUsed_AfterArgs _afterset_IsUsed;
private static void set_IsUsed(Action< bool> orig,  bool value)
{
Delegates.Params_set_IsUsed @params = new() 
{
value = value
};
if (_beforeset_IsUsed != null)
{
foreach (Delegates.set_IsUsed_BeforeArgs toInvoke in _beforeset_IsUsed.GetInvocationList())
{
try
{
_beforeset_IsUsed?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
value = @params.value;
orig(value);
if (_afterset_IsUsed != null)
{
foreach (Delegates.set_IsUsed_AfterArgs toInvoke in _afterset_IsUsed.GetInvocationList())
{
try
{
_afterset_IsUsed.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void Hookget_IsRestartRequired()
{
if (!HookedList.Contains("get_IsRestartRequired"))
{
HookedList.Add("get_IsRestartRequired");
new Hook(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsRestartRequired", false), get_IsRestartRequired);

}
}
internal static event Delegates.get_IsRestartRequired_BeforeArgs _beforeget_IsRestartRequired;
internal static event Delegates.get_IsRestartRequired_AfterArgs _afterget_IsRestartRequired;
private static bool get_IsRestartRequired(Func<bool> orig)
{
if (_beforeget_IsRestartRequired != null)
{
foreach (Delegates.get_IsRestartRequired_BeforeArgs toInvoke in _beforeget_IsRestartRequired.GetInvocationList())
{
try
{
_beforeget_IsRestartRequired?.Invoke();
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
var retVal = orig();
if (_afterget_IsRestartRequired != null)
{
foreach (Delegates.get_IsRestartRequired_AfterArgs toInvoke in _afterget_IsRestartRequired.GetInvocationList())
{
try
{
retVal = _afterget_IsRestartRequired.Invoke(retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookAwake()
{
if (!HookedList.Contains("Awake"))
{
HookedList.Add("Awake");
On.NativeInputModuleManager.Awake += Awake;

}
}
internal static event Delegates.Awake_BeforeArgs _beforeAwake;
internal static event Delegates.Awake_AfterArgs _afterAwake;
private static void Awake(On.NativeInputModuleManager.orig_Awake orig,NativeInputModuleManager self)
{
Delegates.Params_Awake @params = new() 
{
self = self
};
if (_beforeAwake != null)
{
foreach (Delegates.Awake_BeforeArgs toInvoke in _beforeAwake.GetInvocationList())
{
try
{
_beforeAwake?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterAwake != null)
{
foreach (Delegates.Awake_AfterArgs toInvoke in _afterAwake.GetInvocationList())
{
try
{
_afterAwake.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookOnDestroy()
{
if (!HookedList.Contains("OnDestroy"))
{
HookedList.Add("OnDestroy");
On.NativeInputModuleManager.OnDestroy += OnDestroy;

}
}
internal static event Delegates.OnDestroy_BeforeArgs _beforeOnDestroy;
internal static event Delegates.OnDestroy_AfterArgs _afterOnDestroy;
private static void OnDestroy(On.NativeInputModuleManager.orig_OnDestroy orig,NativeInputModuleManager self)
{
Delegates.Params_OnDestroy @params = new() 
{
self = self
};
if (_beforeOnDestroy != null)
{
foreach (Delegates.OnDestroy_BeforeArgs toInvoke in _beforeOnDestroy.GetInvocationList())
{
try
{
_beforeOnDestroy?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterOnDestroy != null)
{
foreach (Delegates.OnDestroy_AfterArgs toInvoke in _afterOnDestroy.GetInvocationList())
{
try
{
_afterOnDestroy.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookOnEnable()
{
if (!HookedList.Contains("OnEnable"))
{
HookedList.Add("OnEnable");
On.NativeInputModuleManager.OnEnable += OnEnable;

}
}
internal static event Delegates.OnEnable_BeforeArgs _beforeOnEnable;
internal static event Delegates.OnEnable_AfterArgs _afterOnEnable;
private static void OnEnable(On.NativeInputModuleManager.orig_OnEnable orig,NativeInputModuleManager self)
{
Delegates.Params_OnEnable @params = new() 
{
self = self
};
if (_beforeOnEnable != null)
{
foreach (Delegates.OnEnable_BeforeArgs toInvoke in _beforeOnEnable.GetInvocationList())
{
try
{
_beforeOnEnable?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterOnEnable != null)
{
foreach (Delegates.OnEnable_AfterArgs toInvoke in _afterOnEnable.GetInvocationList())
{
try
{
_afterOnEnable.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookChangeIsUsed()
{
if (!HookedList.Contains("ChangeIsUsed"))
{
HookedList.Add("ChangeIsUsed");
On.NativeInputModuleManager.ChangeIsUsed += ChangeIsUsed;

}
}
internal static event Delegates.ChangeIsUsed_BeforeArgs _beforeChangeIsUsed;
internal static event Delegates.ChangeIsUsed_AfterArgs _afterChangeIsUsed;
private static void ChangeIsUsed(On.NativeInputModuleManager.orig_ChangeIsUsed orig, bool willUse)
{
Delegates.Params_ChangeIsUsed @params = new() 
{
willUse = willUse
};
if (_beforeChangeIsUsed != null)
{
foreach (Delegates.ChangeIsUsed_BeforeArgs toInvoke in _beforeChangeIsUsed.GetInvocationList())
{
try
{
_beforeChangeIsUsed?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
willUse = @params.willUse;
orig(willUse);
if (_afterChangeIsUsed != null)
{
foreach (Delegates.ChangeIsUsed_AfterArgs toInvoke in _afterChangeIsUsed.GetInvocationList())
{
try
{
_afterChangeIsUsed.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
}

/// <summary>
/// Contains necessary information to create Hooks. Does not contain any hooks
/// </summary>
public static class Delegates
{
public delegate void get_IsUsed_BeforeArgs();
public delegate bool get_IsUsed_AfterArgs(bool ret);
public delegate bool get_IsUsed_WithArgs (Func<bool> orig);
public sealed class Params_set_IsUsed
{
public bool value;
}
public delegate void set_IsUsed_BeforeArgs(Params_set_IsUsed args);
public delegate void set_IsUsed_AfterArgs(Params_set_IsUsed args);
public delegate void set_IsUsed_WithArgs (Action< bool> orig,  bool value);
public delegate void get_IsRestartRequired_BeforeArgs();
public delegate bool get_IsRestartRequired_AfterArgs(bool ret);
public delegate bool get_IsRestartRequired_WithArgs (Func<bool> orig);
public sealed class Params_Awake
{
public NativeInputModuleManager self;
}
public delegate void Awake_BeforeArgs(Params_Awake args);
public delegate void Awake_AfterArgs(Params_Awake args);
public delegate void Awake_WithArgs (Action<NativeInputModuleManager> orig, NativeInputModuleManager self);
public sealed class Params_OnDestroy
{
public NativeInputModuleManager self;
}
public delegate void OnDestroy_BeforeArgs(Params_OnDestroy args);
public delegate void OnDestroy_AfterArgs(Params_OnDestroy args);
public delegate void OnDestroy_WithArgs (Action<NativeInputModuleManager> orig, NativeInputModuleManager self);
public sealed class Params_OnEnable
{
public NativeInputModuleManager self;
}
public delegate void OnEnable_BeforeArgs(Params_OnEnable args);
public delegate void OnEnable_AfterArgs(Params_OnEnable args);
public delegate void OnEnable_WithArgs (Action<NativeInputModuleManager> orig, NativeInputModuleManager self);
public sealed class Params_ChangeIsUsed
{
public bool willUse;
}
public delegate void ChangeIsUsed_BeforeArgs(Params_ChangeIsUsed args);
public delegate void ChangeIsUsed_AfterArgs(Params_ChangeIsUsed args);
public delegate void ChangeIsUsed_WithArgs (Action< bool> orig,  bool willUse);
}

/// <summary>
/// Contains Hooks to that run code before orig(self) is called
/// </summary>
public static class BeforeOrig
{
public static event Delegates.get_IsUsed_BeforeArgs get_IsUsed
{
add
{

HookHandler._beforeget_IsUsed += value;
HookHandler.Hookget_IsUsed();
}
remove => HookHandler._beforeget_IsUsed -= value;
}
public static event Delegates.set_IsUsed_BeforeArgs set_IsUsed
{
add
{

HookHandler._beforeset_IsUsed += value;
HookHandler.Hookset_IsUsed();
}
remove => HookHandler._beforeset_IsUsed -= value;
}
public static event Delegates.get_IsRestartRequired_BeforeArgs get_IsRestartRequired
{
add
{

HookHandler._beforeget_IsRestartRequired += value;
HookHandler.Hookget_IsRestartRequired();
}
remove => HookHandler._beforeget_IsRestartRequired -= value;
}
public static event Delegates.Awake_BeforeArgs Awake
{
add
{

HookHandler._beforeAwake += value;
HookHandler.HookAwake();
}
remove => HookHandler._beforeAwake -= value;
}
public static event Delegates.OnDestroy_BeforeArgs OnDestroy
{
add
{

HookHandler._beforeOnDestroy += value;
HookHandler.HookOnDestroy();
}
remove => HookHandler._beforeOnDestroy -= value;
}
public static event Delegates.OnEnable_BeforeArgs OnEnable
{
add
{

HookHandler._beforeOnEnable += value;
HookHandler.HookOnEnable();
}
remove => HookHandler._beforeOnEnable -= value;
}
public static event Delegates.ChangeIsUsed_BeforeArgs ChangeIsUsed
{
add
{

HookHandler._beforeChangeIsUsed += value;
HookHandler.HookChangeIsUsed();
}
remove => HookHandler._beforeChangeIsUsed -= value;
}
}

/// <summary>
/// Contains Hooks to that run code after orig(self) is called
/// </summary>
public static class AfterOrig
{
public static event Delegates.get_IsUsed_AfterArgs get_IsUsed
{
add
{

HookHandler._afterget_IsUsed += value;
HookHandler.Hookget_IsUsed();
}
remove => HookHandler._afterget_IsUsed -= value;
}
public static event Delegates.set_IsUsed_AfterArgs set_IsUsed
{
add
{

HookHandler._afterset_IsUsed += value;
HookHandler.Hookset_IsUsed();
}
remove => HookHandler._afterset_IsUsed -= value;
}
public static event Delegates.get_IsRestartRequired_AfterArgs get_IsRestartRequired
{
add
{

HookHandler._afterget_IsRestartRequired += value;
HookHandler.Hookget_IsRestartRequired();
}
remove => HookHandler._afterget_IsRestartRequired -= value;
}
public static event Delegates.Awake_AfterArgs Awake
{
add
{

HookHandler._afterAwake += value;
HookHandler.HookAwake();
}
remove => HookHandler._afterAwake -= value;
}
public static event Delegates.OnDestroy_AfterArgs OnDestroy
{
add
{

HookHandler._afterOnDestroy += value;
HookHandler.HookOnDestroy();
}
remove => HookHandler._afterOnDestroy -= value;
}
public static event Delegates.OnEnable_AfterArgs OnEnable
{
add
{

HookHandler._afterOnEnable += value;
HookHandler.HookOnEnable();
}
remove => HookHandler._afterOnEnable -= value;
}
public static event Delegates.ChangeIsUsed_AfterArgs ChangeIsUsed
{
add
{

HookHandler._afterChangeIsUsed += value;
HookHandler.HookChangeIsUsed();
}
remove => HookHandler._afterChangeIsUsed -= value;
}
}

/// <summary>
/// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
/// </summary>
public static class WithOrig
{
public static event Delegates.get_IsUsed_WithArgs get_IsUsed
{
add => HookEndpointManager.Add<Delegates.get_IsUsed_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsUsed", false), value);
remove => HookEndpointManager.Remove<Delegates.get_IsUsed_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsUsed", false), value);
}
public static event Delegates.set_IsUsed_WithArgs set_IsUsed
{
add => HookEndpointManager.Add<Delegates.set_IsUsed_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "set_IsUsed", false), value);
remove => HookEndpointManager.Remove<Delegates.set_IsUsed_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "set_IsUsed", false), value);
}
public static event Delegates.get_IsRestartRequired_WithArgs get_IsRestartRequired
{
add => HookEndpointManager.Add<Delegates.get_IsRestartRequired_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsRestartRequired", false), value);
remove => HookEndpointManager.Remove<Delegates.get_IsRestartRequired_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(NativeInputModuleManager), "get_IsRestartRequired", false), value);
}
public static event On.NativeInputModuleManager.hook_Awake Awake
{
add => On.NativeInputModuleManager.Awake += value;
remove => On.NativeInputModuleManager.Awake -= value;
}
public static event On.NativeInputModuleManager.hook_OnDestroy OnDestroy
{
add => On.NativeInputModuleManager.OnDestroy += value;
remove => On.NativeInputModuleManager.OnDestroy -= value;
}
public static event On.NativeInputModuleManager.hook_OnEnable OnEnable
{
add => On.NativeInputModuleManager.OnEnable += value;
remove => On.NativeInputModuleManager.OnEnable -= value;
}
public static event On.NativeInputModuleManager.hook_ChangeIsUsed ChangeIsUsed
{
add => On.NativeInputModuleManager.ChangeIsUsed += value;
remove => On.NativeInputModuleManager.ChangeIsUsed -= value;
}
}

}

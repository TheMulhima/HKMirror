namespace HKMirror.Hooks.OnHooks;

/// <summary>
///     Contains different types of On Hooks for SaveDataUpgradeHandler class.<br />
///     Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnSaveDataUpgradeHandler
{
    internal static class HookHandler
    {
        private static readonly List<string> HookedList = new();

        internal static void HookCleanupVersionText()
        {
            if (!HookedList.Contains("CleanupVersionText"))
            {
                HookedList.Add("CleanupVersionText");
                On.SaveDataUpgradeHandler.CleanupVersionText += CleanupVersionText;
            }
        }

        internal static event Delegates.CleanupVersionText_BeforeArgs _beforeCleanupVersionText;
        internal static event Delegates.CleanupVersionText_AfterArgs _afterCleanupVersionText;

        private static string CleanupVersionText(On.SaveDataUpgradeHandler.orig_CleanupVersionText orig,
            string versionText)
        {
            Delegates.Params_CleanupVersionText @params = new()
            {
                versionText = versionText
            };
            if (_beforeCleanupVersionText != null)
                foreach (Delegates.CleanupVersionText_BeforeArgs toInvoke in
                         _beforeCleanupVersionText.GetInvocationList())
                    try
                    {
                        _beforeCleanupVersionText?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            versionText = @params.versionText;
            var retVal = orig(versionText);
            if (_afterCleanupVersionText != null)
                foreach (Delegates.CleanupVersionText_AfterArgs toInvoke in
                         _afterCleanupVersionText.GetInvocationList())
                    try
                    {
                        retVal = _afterCleanupVersionText.Invoke(@params, retVal);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            return retVal;
        }

        internal static void HookUpgradeSaveData()
        {
            if (!HookedList.Contains("UpgradeSaveData"))
            {
                HookedList.Add("UpgradeSaveData");
                On.SaveDataUpgradeHandler.UpgradeSaveData += UpgradeSaveData;
            }
        }

        internal static event Delegates.UpgradeSaveData_BeforeArgs _beforeUpgradeSaveData;
        internal static event Delegates.UpgradeSaveData_AfterArgs _afterUpgradeSaveData;

        private static void UpgradeSaveData(On.SaveDataUpgradeHandler.orig_UpgradeSaveData orig,
            ref PlayerData playerData)
        {
            Delegates.Params_UpgradeSaveData @params = new()
            {
                playerData = playerData
            };
            if (_beforeUpgradeSaveData != null)
                foreach (Delegates.UpgradeSaveData_BeforeArgs toInvoke in _beforeUpgradeSaveData.GetInvocationList())
                    try
                    {
                        _beforeUpgradeSaveData?.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }

            playerData = @params.playerData;
            orig(ref playerData);
            if (_afterUpgradeSaveData != null)
                foreach (Delegates.UpgradeSaveData_AfterArgs toInvoke in _afterUpgradeSaveData.GetInvocationList())
                    try
                    {
                        _afterUpgradeSaveData.Invoke(@params);
                    }
                    catch (Exception e)
                    {
                        HKMirrorMod.DoLogError(e);
                    }
        }
    }

    /// <summary>
    ///     Contains necessary information to create Hooks. Does not contain any hooks
    /// </summary>
    public static class Delegates
    {
        public delegate string CleanupVersionText_AfterArgs(Params_CleanupVersionText args, string ret);

        public delegate void CleanupVersionText_BeforeArgs(Params_CleanupVersionText args);

        public delegate string CleanupVersionText_WithArgs(Func<string, string> orig, string versionText);

        public delegate void UpgradeSaveData_AfterArgs(Params_UpgradeSaveData args);

        public delegate void UpgradeSaveData_BeforeArgs(Params_UpgradeSaveData args);

        public delegate void UpgradeSaveData_WithArgs(Action<PlayerData> orig, ref PlayerData playerData);

        public sealed class Params_CleanupVersionText
        {
            public string versionText;
        }

        public sealed class Params_UpgradeSaveData
        {
            public PlayerData playerData;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code before orig(self) is called
    /// </summary>
    public static class BeforeOrig
    {
        public static event Delegates.CleanupVersionText_BeforeArgs CleanupVersionText
        {
            add
            {
                HookHandler._beforeCleanupVersionText += value;
                HookHandler.HookCleanupVersionText();
            }
            remove => HookHandler._beforeCleanupVersionText -= value;
        }

        public static event Delegates.UpgradeSaveData_BeforeArgs UpgradeSaveData
        {
            add
            {
                HookHandler._beforeUpgradeSaveData += value;
                HookHandler.HookUpgradeSaveData();
            }
            remove => HookHandler._beforeUpgradeSaveData -= value;
        }
    }

    /// <summary>
    ///     Contains Hooks to that run code after orig(self) is called
    /// </summary>
    public static class AfterOrig
    {
        public static event Delegates.CleanupVersionText_AfterArgs CleanupVersionText
        {
            add
            {
                HookHandler._afterCleanupVersionText += value;
                HookHandler.HookCleanupVersionText();
            }
            remove => HookHandler._afterCleanupVersionText -= value;
        }

        public static event Delegates.UpgradeSaveData_AfterArgs UpgradeSaveData
        {
            add
            {
                HookHandler._afterUpgradeSaveData += value;
                HookHandler.HookUpgradeSaveData();
            }
            remove => HookHandler._afterUpgradeSaveData -= value;
        }
    }

    /// <summary>
    ///     Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property
    ///     getters/setters
    /// </summary>
    public static class WithOrig
    {
        public static event On.SaveDataUpgradeHandler.hook_CleanupVersionText CleanupVersionText
        {
            add => On.SaveDataUpgradeHandler.CleanupVersionText += value;
            remove => On.SaveDataUpgradeHandler.CleanupVersionText -= value;
        }

        public static event On.SaveDataUpgradeHandler.hook_UpgradeSaveData UpgradeSaveData
        {
            add => On.SaveDataUpgradeHandler.UpgradeSaveData += value;
            remove => On.SaveDataUpgradeHandler.UpgradeSaveData -= value;
        }
    }
}
using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
namespace HKMirror.Hooks.OnHooks;
/// <summary>
/// Contains different types of On Hooks for tk2dStaticSpriteBatcher class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class Ontk2dStaticSpriteBatcher
{
internal static class HookHandler
{
private static List<string> HookedList = new List<string>();
internal static void HookAwake()
{
if (!HookedList.Contains("Awake"))
{
HookedList.Add("Awake");
On.tk2dStaticSpriteBatcher.Awake += Awake;

}
}
internal static event Delegates.Awake_BeforeArgs _beforeAwake;
internal static event Delegates.Awake_AfterArgs _afterAwake;
private static void Awake(On.tk2dStaticSpriteBatcher.orig_Awake orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_Awake @params = new() 
{
self = self
};
if (_beforeAwake != null)
{
foreach (Delegates.Awake_BeforeArgs toInvoke in _beforeAwake.GetInvocationList())
{
try
{
_beforeAwake?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterAwake != null)
{
foreach (Delegates.Awake_AfterArgs toInvoke in _afterAwake.GetInvocationList())
{
try
{
_afterAwake.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookUpgradeData()
{
if (!HookedList.Contains("UpgradeData"))
{
HookedList.Add("UpgradeData");
On.tk2dStaticSpriteBatcher.UpgradeData += UpgradeData;

}
}
internal static event Delegates.UpgradeData_BeforeArgs _beforeUpgradeData;
internal static event Delegates.UpgradeData_AfterArgs _afterUpgradeData;
private static bool UpgradeData(On.tk2dStaticSpriteBatcher.orig_UpgradeData orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_UpgradeData @params = new() 
{
self = self
};
if (_beforeUpgradeData != null)
{
foreach (Delegates.UpgradeData_BeforeArgs toInvoke in _beforeUpgradeData.GetInvocationList())
{
try
{
_beforeUpgradeData?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
var retVal = orig(self);
if (_afterUpgradeData != null)
{
foreach (Delegates.UpgradeData_AfterArgs toInvoke in _afterUpgradeData.GetInvocationList())
{
try
{
retVal = _afterUpgradeData.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookOnDestroy()
{
if (!HookedList.Contains("OnDestroy"))
{
HookedList.Add("OnDestroy");
On.tk2dStaticSpriteBatcher.OnDestroy += OnDestroy;

}
}
internal static event Delegates.OnDestroy_BeforeArgs _beforeOnDestroy;
internal static event Delegates.OnDestroy_AfterArgs _afterOnDestroy;
private static void OnDestroy(On.tk2dStaticSpriteBatcher.orig_OnDestroy orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_OnDestroy @params = new() 
{
self = self
};
if (_beforeOnDestroy != null)
{
foreach (Delegates.OnDestroy_BeforeArgs toInvoke in _beforeOnDestroy.GetInvocationList())
{
try
{
_beforeOnDestroy?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterOnDestroy != null)
{
foreach (Delegates.OnDestroy_AfterArgs toInvoke in _afterOnDestroy.GetInvocationList())
{
try
{
_afterOnDestroy.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookUpdateMatrices()
{
if (!HookedList.Contains("UpdateMatrices"))
{
HookedList.Add("UpdateMatrices");
On.tk2dStaticSpriteBatcher.UpdateMatrices += UpdateMatrices;

}
}
internal static event Delegates.UpdateMatrices_BeforeArgs _beforeUpdateMatrices;
internal static event Delegates.UpdateMatrices_AfterArgs _afterUpdateMatrices;
private static void UpdateMatrices(On.tk2dStaticSpriteBatcher.orig_UpdateMatrices orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_UpdateMatrices @params = new() 
{
self = self
};
if (_beforeUpdateMatrices != null)
{
foreach (Delegates.UpdateMatrices_BeforeArgs toInvoke in _beforeUpdateMatrices.GetInvocationList())
{
try
{
_beforeUpdateMatrices?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterUpdateMatrices != null)
{
foreach (Delegates.UpdateMatrices_AfterArgs toInvoke in _afterUpdateMatrices.GetInvocationList())
{
try
{
_afterUpdateMatrices.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookBuild()
{
if (!HookedList.Contains("Build"))
{
HookedList.Add("Build");
On.tk2dStaticSpriteBatcher.Build += Build;

}
}
internal static event Delegates.Build_BeforeArgs _beforeBuild;
internal static event Delegates.Build_AfterArgs _afterBuild;
private static void Build(On.tk2dStaticSpriteBatcher.orig_Build orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_Build @params = new() 
{
self = self
};
if (_beforeBuild != null)
{
foreach (Delegates.Build_BeforeArgs toInvoke in _beforeBuild.GetInvocationList())
{
try
{
_beforeBuild?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterBuild != null)
{
foreach (Delegates.Build_AfterArgs toInvoke in _afterBuild.GetInvocationList())
{
try
{
_afterBuild.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookSortBatchedSprites()
{
if (!HookedList.Contains("SortBatchedSprites"))
{
HookedList.Add("SortBatchedSprites");
On.tk2dStaticSpriteBatcher.SortBatchedSprites += SortBatchedSprites;

}
}
internal static event Delegates.SortBatchedSprites_BeforeArgs _beforeSortBatchedSprites;
internal static event Delegates.SortBatchedSprites_AfterArgs _afterSortBatchedSprites;
private static void SortBatchedSprites(On.tk2dStaticSpriteBatcher.orig_SortBatchedSprites orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_SortBatchedSprites @params = new() 
{
self = self
};
if (_beforeSortBatchedSprites != null)
{
foreach (Delegates.SortBatchedSprites_BeforeArgs toInvoke in _beforeSortBatchedSprites.GetInvocationList())
{
try
{
_beforeSortBatchedSprites?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterSortBatchedSprites != null)
{
foreach (Delegates.SortBatchedSprites_AfterArgs toInvoke in _afterSortBatchedSprites.GetInvocationList())
{
try
{
_afterSortBatchedSprites.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookGetMaterial()
{
if (!HookedList.Contains("GetMaterial"))
{
HookedList.Add("GetMaterial");
On.tk2dStaticSpriteBatcher.GetMaterial += GetMaterial;

}
}
internal static event Delegates.GetMaterial_BeforeArgs _beforeGetMaterial;
internal static event Delegates.GetMaterial_AfterArgs _afterGetMaterial;
private static UnityEngine.Material GetMaterial(On.tk2dStaticSpriteBatcher.orig_GetMaterial orig,tk2dStaticSpriteBatcher self,  tk2dBatchedSprite bs)
{
Delegates.Params_GetMaterial @params = new() 
{
self = self
, bs = bs
};
if (_beforeGetMaterial != null)
{
foreach (Delegates.GetMaterial_BeforeArgs toInvoke in _beforeGetMaterial.GetInvocationList())
{
try
{
_beforeGetMaterial?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
bs = @params.bs;
var retVal = orig(self, bs);
if (_afterGetMaterial != null)
{
foreach (Delegates.GetMaterial_AfterArgs toInvoke in _afterGetMaterial.GetInvocationList())
{
try
{
retVal = _afterGetMaterial.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookBuildRenderMesh()
{
if (!HookedList.Contains("BuildRenderMesh"))
{
HookedList.Add("BuildRenderMesh");
On.tk2dStaticSpriteBatcher.BuildRenderMesh += BuildRenderMesh;

}
}
internal static event Delegates.BuildRenderMesh_BeforeArgs _beforeBuildRenderMesh;
internal static event Delegates.BuildRenderMesh_AfterArgs _afterBuildRenderMesh;
private static void BuildRenderMesh(On.tk2dStaticSpriteBatcher.orig_BuildRenderMesh orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_BuildRenderMesh @params = new() 
{
self = self
};
if (_beforeBuildRenderMesh != null)
{
foreach (Delegates.BuildRenderMesh_BeforeArgs toInvoke in _beforeBuildRenderMesh.GetInvocationList())
{
try
{
_beforeBuildRenderMesh?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterBuildRenderMesh != null)
{
foreach (Delegates.BuildRenderMesh_AfterArgs toInvoke in _afterBuildRenderMesh.GetInvocationList())
{
try
{
_afterBuildRenderMesh.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookBuildPhysicsMesh()
{
if (!HookedList.Contains("BuildPhysicsMesh"))
{
HookedList.Add("BuildPhysicsMesh");
On.tk2dStaticSpriteBatcher.BuildPhysicsMesh += BuildPhysicsMesh;

}
}
internal static event Delegates.BuildPhysicsMesh_BeforeArgs _beforeBuildPhysicsMesh;
internal static event Delegates.BuildPhysicsMesh_AfterArgs _afterBuildPhysicsMesh;
private static void BuildPhysicsMesh(On.tk2dStaticSpriteBatcher.orig_BuildPhysicsMesh orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_BuildPhysicsMesh @params = new() 
{
self = self
};
if (_beforeBuildPhysicsMesh != null)
{
foreach (Delegates.BuildPhysicsMesh_BeforeArgs toInvoke in _beforeBuildPhysicsMesh.GetInvocationList())
{
try
{
_beforeBuildPhysicsMesh?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterBuildPhysicsMesh != null)
{
foreach (Delegates.BuildPhysicsMesh_AfterArgs toInvoke in _afterBuildPhysicsMesh.GetInvocationList())
{
try
{
_afterBuildPhysicsMesh.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookBuildPhysicsMesh2D()
{
if (!HookedList.Contains("BuildPhysicsMesh2D"))
{
HookedList.Add("BuildPhysicsMesh2D");
On.tk2dStaticSpriteBatcher.BuildPhysicsMesh2D += BuildPhysicsMesh2D;

}
}
internal static event Delegates.BuildPhysicsMesh2D_BeforeArgs _beforeBuildPhysicsMesh2D;
internal static event Delegates.BuildPhysicsMesh2D_AfterArgs _afterBuildPhysicsMesh2D;
private static void BuildPhysicsMesh2D(On.tk2dStaticSpriteBatcher.orig_BuildPhysicsMesh2D orig,tk2dStaticSpriteBatcher self,  UnityEngine.EdgeCollider2D[] edgeColliders,  int numEdgeColliders)
{
Delegates.Params_BuildPhysicsMesh2D @params = new() 
{
self = self
, edgeColliders = edgeColliders
, numEdgeColliders = numEdgeColliders
};
if (_beforeBuildPhysicsMesh2D != null)
{
foreach (Delegates.BuildPhysicsMesh2D_BeforeArgs toInvoke in _beforeBuildPhysicsMesh2D.GetInvocationList())
{
try
{
_beforeBuildPhysicsMesh2D?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
edgeColliders = @params.edgeColliders;
numEdgeColliders = @params.numEdgeColliders;
orig(self, edgeColliders, numEdgeColliders);
if (_afterBuildPhysicsMesh2D != null)
{
foreach (Delegates.BuildPhysicsMesh2D_AfterArgs toInvoke in _afterBuildPhysicsMesh2D.GetInvocationList())
{
try
{
_afterBuildPhysicsMesh2D.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookBuildPhysicsMesh3D()
{
if (!HookedList.Contains("BuildPhysicsMesh3D"))
{
HookedList.Add("BuildPhysicsMesh3D");
On.tk2dStaticSpriteBatcher.BuildPhysicsMesh3D += BuildPhysicsMesh3D;

}
}
internal static event Delegates.BuildPhysicsMesh3D_BeforeArgs _beforeBuildPhysicsMesh3D;
internal static event Delegates.BuildPhysicsMesh3D_AfterArgs _afterBuildPhysicsMesh3D;
private static void BuildPhysicsMesh3D(On.tk2dStaticSpriteBatcher.orig_BuildPhysicsMesh3D orig,tk2dStaticSpriteBatcher self,  UnityEngine.MeshCollider meshCollider,  bool flattenDepth,  int numVertices,  int numIndices)
{
Delegates.Params_BuildPhysicsMesh3D @params = new() 
{
self = self
, meshCollider = meshCollider
, flattenDepth = flattenDepth
, numVertices = numVertices
, numIndices = numIndices
};
if (_beforeBuildPhysicsMesh3D != null)
{
foreach (Delegates.BuildPhysicsMesh3D_BeforeArgs toInvoke in _beforeBuildPhysicsMesh3D.GetInvocationList())
{
try
{
_beforeBuildPhysicsMesh3D?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
meshCollider = @params.meshCollider;
flattenDepth = @params.flattenDepth;
numVertices = @params.numVertices;
numIndices = @params.numIndices;
orig(self, meshCollider, flattenDepth, numVertices, numIndices);
if (_afterBuildPhysicsMesh3D != null)
{
foreach (Delegates.BuildPhysicsMesh3D_AfterArgs toInvoke in _afterBuildPhysicsMesh3D.GetInvocationList())
{
try
{
_afterBuildPhysicsMesh3D.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookUsesSpriteCollection()
{
if (!HookedList.Contains("UsesSpriteCollection"))
{
HookedList.Add("UsesSpriteCollection");
On.tk2dStaticSpriteBatcher.UsesSpriteCollection += UsesSpriteCollection;

}
}
internal static event Delegates.UsesSpriteCollection_BeforeArgs _beforeUsesSpriteCollection;
internal static event Delegates.UsesSpriteCollection_AfterArgs _afterUsesSpriteCollection;
private static bool UsesSpriteCollection(On.tk2dStaticSpriteBatcher.orig_UsesSpriteCollection orig,tk2dStaticSpriteBatcher self,  tk2dSpriteCollectionData spriteCollection)
{
Delegates.Params_UsesSpriteCollection @params = new() 
{
self = self
, spriteCollection = spriteCollection
};
if (_beforeUsesSpriteCollection != null)
{
foreach (Delegates.UsesSpriteCollection_BeforeArgs toInvoke in _beforeUsesSpriteCollection.GetInvocationList())
{
try
{
_beforeUsesSpriteCollection?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
spriteCollection = @params.spriteCollection;
var retVal = orig(self, spriteCollection);
if (_afterUsesSpriteCollection != null)
{
foreach (Delegates.UsesSpriteCollection_AfterArgs toInvoke in _afterUsesSpriteCollection.GetInvocationList())
{
try
{
retVal = _afterUsesSpriteCollection.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookForceBuild()
{
if (!HookedList.Contains("ForceBuild"))
{
HookedList.Add("ForceBuild");
On.tk2dStaticSpriteBatcher.ForceBuild += ForceBuild;

}
}
internal static event Delegates.ForceBuild_BeforeArgs _beforeForceBuild;
internal static event Delegates.ForceBuild_AfterArgs _afterForceBuild;
private static void ForceBuild(On.tk2dStaticSpriteBatcher.orig_ForceBuild orig,tk2dStaticSpriteBatcher self)
{
Delegates.Params_ForceBuild @params = new() 
{
self = self
};
if (_beforeForceBuild != null)
{
foreach (Delegates.ForceBuild_BeforeArgs toInvoke in _beforeForceBuild.GetInvocationList())
{
try
{
_beforeForceBuild?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterForceBuild != null)
{
foreach (Delegates.ForceBuild_AfterArgs toInvoke in _afterForceBuild.GetInvocationList())
{
try
{
_afterForceBuild.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
}

/// <summary>
/// Contains necessary information to create Hooks. Does not contain any hooks
/// </summary>
public static class Delegates
{
public sealed class Params_Awake
{
public tk2dStaticSpriteBatcher self;
}
public delegate void Awake_BeforeArgs(Params_Awake args);
public delegate void Awake_AfterArgs(Params_Awake args);
public delegate void Awake_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_UpgradeData
{
public tk2dStaticSpriteBatcher self;
}
public delegate void UpgradeData_BeforeArgs(Params_UpgradeData args);
public delegate bool UpgradeData_AfterArgs(Params_UpgradeData args, bool ret);
public delegate bool UpgradeData_WithArgs (Func<tk2dStaticSpriteBatcher, bool> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_OnDestroy
{
public tk2dStaticSpriteBatcher self;
}
public delegate void OnDestroy_BeforeArgs(Params_OnDestroy args);
public delegate void OnDestroy_AfterArgs(Params_OnDestroy args);
public delegate void OnDestroy_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_UpdateMatrices
{
public tk2dStaticSpriteBatcher self;
}
public delegate void UpdateMatrices_BeforeArgs(Params_UpdateMatrices args);
public delegate void UpdateMatrices_AfterArgs(Params_UpdateMatrices args);
public delegate void UpdateMatrices_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_Build
{
public tk2dStaticSpriteBatcher self;
}
public delegate void Build_BeforeArgs(Params_Build args);
public delegate void Build_AfterArgs(Params_Build args);
public delegate void Build_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_SortBatchedSprites
{
public tk2dStaticSpriteBatcher self;
}
public delegate void SortBatchedSprites_BeforeArgs(Params_SortBatchedSprites args);
public delegate void SortBatchedSprites_AfterArgs(Params_SortBatchedSprites args);
public delegate void SortBatchedSprites_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_GetMaterial
{
public tk2dStaticSpriteBatcher self;
public tk2dBatchedSprite bs;
}
public delegate void GetMaterial_BeforeArgs(Params_GetMaterial args);
public delegate UnityEngine.Material GetMaterial_AfterArgs(Params_GetMaterial args, UnityEngine.Material ret);
public delegate UnityEngine.Material GetMaterial_WithArgs (Func<tk2dStaticSpriteBatcher,  tk2dBatchedSprite, UnityEngine.Material> orig, tk2dStaticSpriteBatcher self,  tk2dBatchedSprite bs);
public sealed class Params_BuildRenderMesh
{
public tk2dStaticSpriteBatcher self;
}
public delegate void BuildRenderMesh_BeforeArgs(Params_BuildRenderMesh args);
public delegate void BuildRenderMesh_AfterArgs(Params_BuildRenderMesh args);
public delegate void BuildRenderMesh_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_BuildPhysicsMesh
{
public tk2dStaticSpriteBatcher self;
}
public delegate void BuildPhysicsMesh_BeforeArgs(Params_BuildPhysicsMesh args);
public delegate void BuildPhysicsMesh_AfterArgs(Params_BuildPhysicsMesh args);
public delegate void BuildPhysicsMesh_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
public sealed class Params_BuildPhysicsMesh2D
{
public tk2dStaticSpriteBatcher self;
public UnityEngine.EdgeCollider2D[] edgeColliders;
public int numEdgeColliders;
}
public delegate void BuildPhysicsMesh2D_BeforeArgs(Params_BuildPhysicsMesh2D args);
public delegate void BuildPhysicsMesh2D_AfterArgs(Params_BuildPhysicsMesh2D args);
public delegate void BuildPhysicsMesh2D_WithArgs (Action<tk2dStaticSpriteBatcher,  UnityEngine.EdgeCollider2D[],  int> orig, tk2dStaticSpriteBatcher self,  UnityEngine.EdgeCollider2D[] edgeColliders,  int numEdgeColliders);
public sealed class Params_BuildPhysicsMesh3D
{
public tk2dStaticSpriteBatcher self;
public UnityEngine.MeshCollider meshCollider;
public bool flattenDepth;
public int numVertices;
public int numIndices;
}
public delegate void BuildPhysicsMesh3D_BeforeArgs(Params_BuildPhysicsMesh3D args);
public delegate void BuildPhysicsMesh3D_AfterArgs(Params_BuildPhysicsMesh3D args);
public delegate void BuildPhysicsMesh3D_WithArgs (Action<tk2dStaticSpriteBatcher,  UnityEngine.MeshCollider,  bool,  int,  int> orig, tk2dStaticSpriteBatcher self,  UnityEngine.MeshCollider meshCollider,  bool flattenDepth,  int numVertices,  int numIndices);
public sealed class Params_UsesSpriteCollection
{
public tk2dStaticSpriteBatcher self;
public tk2dSpriteCollectionData spriteCollection;
}
public delegate void UsesSpriteCollection_BeforeArgs(Params_UsesSpriteCollection args);
public delegate bool UsesSpriteCollection_AfterArgs(Params_UsesSpriteCollection args, bool ret);
public delegate bool UsesSpriteCollection_WithArgs (Func<tk2dStaticSpriteBatcher,  tk2dSpriteCollectionData, bool> orig, tk2dStaticSpriteBatcher self,  tk2dSpriteCollectionData spriteCollection);
public sealed class Params_ForceBuild
{
public tk2dStaticSpriteBatcher self;
}
public delegate void ForceBuild_BeforeArgs(Params_ForceBuild args);
public delegate void ForceBuild_AfterArgs(Params_ForceBuild args);
public delegate void ForceBuild_WithArgs (Action<tk2dStaticSpriteBatcher> orig, tk2dStaticSpriteBatcher self);
}

/// <summary>
/// Contains Hooks to that run code before orig(self) is called
/// </summary>
public static class BeforeOrig
{
public static event Delegates.Awake_BeforeArgs Awake
{
add
{

HookHandler._beforeAwake += value;
HookHandler.HookAwake();
}
remove => HookHandler._beforeAwake -= value;
}
public static event Delegates.UpgradeData_BeforeArgs UpgradeData
{
add
{

HookHandler._beforeUpgradeData += value;
HookHandler.HookUpgradeData();
}
remove => HookHandler._beforeUpgradeData -= value;
}
public static event Delegates.OnDestroy_BeforeArgs OnDestroy
{
add
{

HookHandler._beforeOnDestroy += value;
HookHandler.HookOnDestroy();
}
remove => HookHandler._beforeOnDestroy -= value;
}
public static event Delegates.UpdateMatrices_BeforeArgs UpdateMatrices
{
add
{

HookHandler._beforeUpdateMatrices += value;
HookHandler.HookUpdateMatrices();
}
remove => HookHandler._beforeUpdateMatrices -= value;
}
public static event Delegates.Build_BeforeArgs Build
{
add
{

HookHandler._beforeBuild += value;
HookHandler.HookBuild();
}
remove => HookHandler._beforeBuild -= value;
}
public static event Delegates.SortBatchedSprites_BeforeArgs SortBatchedSprites
{
add
{

HookHandler._beforeSortBatchedSprites += value;
HookHandler.HookSortBatchedSprites();
}
remove => HookHandler._beforeSortBatchedSprites -= value;
}
public static event Delegates.GetMaterial_BeforeArgs GetMaterial
{
add
{

HookHandler._beforeGetMaterial += value;
HookHandler.HookGetMaterial();
}
remove => HookHandler._beforeGetMaterial -= value;
}
public static event Delegates.BuildRenderMesh_BeforeArgs BuildRenderMesh
{
add
{

HookHandler._beforeBuildRenderMesh += value;
HookHandler.HookBuildRenderMesh();
}
remove => HookHandler._beforeBuildRenderMesh -= value;
}
public static event Delegates.BuildPhysicsMesh_BeforeArgs BuildPhysicsMesh
{
add
{

HookHandler._beforeBuildPhysicsMesh += value;
HookHandler.HookBuildPhysicsMesh();
}
remove => HookHandler._beforeBuildPhysicsMesh -= value;
}
public static event Delegates.BuildPhysicsMesh2D_BeforeArgs BuildPhysicsMesh2D
{
add
{

HookHandler._beforeBuildPhysicsMesh2D += value;
HookHandler.HookBuildPhysicsMesh2D();
}
remove => HookHandler._beforeBuildPhysicsMesh2D -= value;
}
public static event Delegates.BuildPhysicsMesh3D_BeforeArgs BuildPhysicsMesh3D
{
add
{

HookHandler._beforeBuildPhysicsMesh3D += value;
HookHandler.HookBuildPhysicsMesh3D();
}
remove => HookHandler._beforeBuildPhysicsMesh3D -= value;
}
public static event Delegates.UsesSpriteCollection_BeforeArgs UsesSpriteCollection
{
add
{

HookHandler._beforeUsesSpriteCollection += value;
HookHandler.HookUsesSpriteCollection();
}
remove => HookHandler._beforeUsesSpriteCollection -= value;
}
public static event Delegates.ForceBuild_BeforeArgs ForceBuild
{
add
{

HookHandler._beforeForceBuild += value;
HookHandler.HookForceBuild();
}
remove => HookHandler._beforeForceBuild -= value;
}
}

/// <summary>
/// Contains Hooks to that run code after orig(self) is called
/// </summary>
public static class AfterOrig
{
public static event Delegates.Awake_AfterArgs Awake
{
add
{

HookHandler._afterAwake += value;
HookHandler.HookAwake();
}
remove => HookHandler._afterAwake -= value;
}
public static event Delegates.UpgradeData_AfterArgs UpgradeData
{
add
{

HookHandler._afterUpgradeData += value;
HookHandler.HookUpgradeData();
}
remove => HookHandler._afterUpgradeData -= value;
}
public static event Delegates.OnDestroy_AfterArgs OnDestroy
{
add
{

HookHandler._afterOnDestroy += value;
HookHandler.HookOnDestroy();
}
remove => HookHandler._afterOnDestroy -= value;
}
public static event Delegates.UpdateMatrices_AfterArgs UpdateMatrices
{
add
{

HookHandler._afterUpdateMatrices += value;
HookHandler.HookUpdateMatrices();
}
remove => HookHandler._afterUpdateMatrices -= value;
}
public static event Delegates.Build_AfterArgs Build
{
add
{

HookHandler._afterBuild += value;
HookHandler.HookBuild();
}
remove => HookHandler._afterBuild -= value;
}
public static event Delegates.SortBatchedSprites_AfterArgs SortBatchedSprites
{
add
{

HookHandler._afterSortBatchedSprites += value;
HookHandler.HookSortBatchedSprites();
}
remove => HookHandler._afterSortBatchedSprites -= value;
}
public static event Delegates.GetMaterial_AfterArgs GetMaterial
{
add
{

HookHandler._afterGetMaterial += value;
HookHandler.HookGetMaterial();
}
remove => HookHandler._afterGetMaterial -= value;
}
public static event Delegates.BuildRenderMesh_AfterArgs BuildRenderMesh
{
add
{

HookHandler._afterBuildRenderMesh += value;
HookHandler.HookBuildRenderMesh();
}
remove => HookHandler._afterBuildRenderMesh -= value;
}
public static event Delegates.BuildPhysicsMesh_AfterArgs BuildPhysicsMesh
{
add
{

HookHandler._afterBuildPhysicsMesh += value;
HookHandler.HookBuildPhysicsMesh();
}
remove => HookHandler._afterBuildPhysicsMesh -= value;
}
public static event Delegates.BuildPhysicsMesh2D_AfterArgs BuildPhysicsMesh2D
{
add
{

HookHandler._afterBuildPhysicsMesh2D += value;
HookHandler.HookBuildPhysicsMesh2D();
}
remove => HookHandler._afterBuildPhysicsMesh2D -= value;
}
public static event Delegates.BuildPhysicsMesh3D_AfterArgs BuildPhysicsMesh3D
{
add
{

HookHandler._afterBuildPhysicsMesh3D += value;
HookHandler.HookBuildPhysicsMesh3D();
}
remove => HookHandler._afterBuildPhysicsMesh3D -= value;
}
public static event Delegates.UsesSpriteCollection_AfterArgs UsesSpriteCollection
{
add
{

HookHandler._afterUsesSpriteCollection += value;
HookHandler.HookUsesSpriteCollection();
}
remove => HookHandler._afterUsesSpriteCollection -= value;
}
public static event Delegates.ForceBuild_AfterArgs ForceBuild
{
add
{

HookHandler._afterForceBuild += value;
HookHandler.HookForceBuild();
}
remove => HookHandler._afterForceBuild -= value;
}
}

/// <summary>
/// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
/// </summary>
public static class WithOrig
{
public static event On.tk2dStaticSpriteBatcher.hook_Awake Awake
{
add => On.tk2dStaticSpriteBatcher.Awake += value;
remove => On.tk2dStaticSpriteBatcher.Awake -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_UpgradeData UpgradeData
{
add => On.tk2dStaticSpriteBatcher.UpgradeData += value;
remove => On.tk2dStaticSpriteBatcher.UpgradeData -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_OnDestroy OnDestroy
{
add => On.tk2dStaticSpriteBatcher.OnDestroy += value;
remove => On.tk2dStaticSpriteBatcher.OnDestroy -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_UpdateMatrices UpdateMatrices
{
add => On.tk2dStaticSpriteBatcher.UpdateMatrices += value;
remove => On.tk2dStaticSpriteBatcher.UpdateMatrices -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_Build Build
{
add => On.tk2dStaticSpriteBatcher.Build += value;
remove => On.tk2dStaticSpriteBatcher.Build -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_SortBatchedSprites SortBatchedSprites
{
add => On.tk2dStaticSpriteBatcher.SortBatchedSprites += value;
remove => On.tk2dStaticSpriteBatcher.SortBatchedSprites -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_GetMaterial GetMaterial
{
add => On.tk2dStaticSpriteBatcher.GetMaterial += value;
remove => On.tk2dStaticSpriteBatcher.GetMaterial -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_BuildRenderMesh BuildRenderMesh
{
add => On.tk2dStaticSpriteBatcher.BuildRenderMesh += value;
remove => On.tk2dStaticSpriteBatcher.BuildRenderMesh -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_BuildPhysicsMesh BuildPhysicsMesh
{
add => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh += value;
remove => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_BuildPhysicsMesh2D BuildPhysicsMesh2D
{
add => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh2D += value;
remove => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh2D -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_BuildPhysicsMesh3D BuildPhysicsMesh3D
{
add => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh3D += value;
remove => On.tk2dStaticSpriteBatcher.BuildPhysicsMesh3D -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_UsesSpriteCollection UsesSpriteCollection
{
add => On.tk2dStaticSpriteBatcher.UsesSpriteCollection += value;
remove => On.tk2dStaticSpriteBatcher.UsesSpriteCollection -= value;
}
public static event On.tk2dStaticSpriteBatcher.hook_ForceBuild ForceBuild
{
add => On.tk2dStaticSpriteBatcher.ForceBuild += value;
remove => On.tk2dStaticSpriteBatcher.ForceBuild -= value;
}
}

}

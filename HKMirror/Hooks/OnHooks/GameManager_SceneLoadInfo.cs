using MonoMod.RuntimeDetour;
using MonoMod.RuntimeDetour.HookGen;
namespace HKMirror.Hooks.OnHooks;
/// <summary>
/// Contains different types of On Hooks for GameManager_SceneLoadInfo class.<br />
/// Contains hooks that aren't generated by monomod, and before and after orig hooks for easier hooking.
/// </summary>
public static class OnGameManager_SceneLoadInfo
{
internal static class HookHandler
{
private static List<string> HookedList = new List<string>();
internal static void HookNotifyFetchComplete()
{
if (!HookedList.Contains("NotifyFetchComplete"))
{
HookedList.Add("NotifyFetchComplete");
new Hook(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFetchComplete", true), NotifyFetchComplete);

}
}
internal static event Delegates.NotifyFetchComplete_BeforeArgs _beforeNotifyFetchComplete;
internal static event Delegates.NotifyFetchComplete_AfterArgs _afterNotifyFetchComplete;
private static void NotifyFetchComplete(Action<GameManager.SceneLoadInfo> orig, GameManager.SceneLoadInfo self)
{
Delegates.Params_NotifyFetchComplete @params = new() 
{
self = self
};
if (_beforeNotifyFetchComplete != null)
{
foreach (Delegates.NotifyFetchComplete_BeforeArgs toInvoke in _beforeNotifyFetchComplete.GetInvocationList())
{
try
{
_beforeNotifyFetchComplete?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterNotifyFetchComplete != null)
{
foreach (Delegates.NotifyFetchComplete_AfterArgs toInvoke in _afterNotifyFetchComplete.GetInvocationList())
{
try
{
_afterNotifyFetchComplete.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
internal static void HookIsReadyToActivate()
{
if (!HookedList.Contains("IsReadyToActivate"))
{
HookedList.Add("IsReadyToActivate");
new Hook(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "IsReadyToActivate", true), IsReadyToActivate);

}
}
internal static event Delegates.IsReadyToActivate_BeforeArgs _beforeIsReadyToActivate;
internal static event Delegates.IsReadyToActivate_AfterArgs _afterIsReadyToActivate;
private static bool IsReadyToActivate(Func<GameManager.SceneLoadInfo, bool> orig, GameManager.SceneLoadInfo self)
{
Delegates.Params_IsReadyToActivate @params = new() 
{
self = self
};
if (_beforeIsReadyToActivate != null)
{
foreach (Delegates.IsReadyToActivate_BeforeArgs toInvoke in _beforeIsReadyToActivate.GetInvocationList())
{
try
{
_beforeIsReadyToActivate?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
var retVal = orig(self);
if (_afterIsReadyToActivate != null)
{
foreach (Delegates.IsReadyToActivate_AfterArgs toInvoke in _afterIsReadyToActivate.GetInvocationList())
{
try
{
retVal = _afterIsReadyToActivate.Invoke(@params, retVal);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
return retVal;
}
internal static void HookNotifyFinished()
{
if (!HookedList.Contains("NotifyFinished"))
{
HookedList.Add("NotifyFinished");
new Hook(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFinished", true), NotifyFinished);

}
}
internal static event Delegates.NotifyFinished_BeforeArgs _beforeNotifyFinished;
internal static event Delegates.NotifyFinished_AfterArgs _afterNotifyFinished;
private static void NotifyFinished(Action<GameManager.SceneLoadInfo> orig, GameManager.SceneLoadInfo self)
{
Delegates.Params_NotifyFinished @params = new() 
{
self = self
};
if (_beforeNotifyFinished != null)
{
foreach (Delegates.NotifyFinished_BeforeArgs toInvoke in _beforeNotifyFinished.GetInvocationList())
{
try
{
_beforeNotifyFinished?.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
self = @params.self;
orig(self);
if (_afterNotifyFinished != null)
{
foreach (Delegates.NotifyFinished_AfterArgs toInvoke in _afterNotifyFinished.GetInvocationList())
{
try
{
_afterNotifyFinished.Invoke(@params);
}
catch (Exception e) 
{ HKMirrorMod.DoLogError(e);
}
}
}
}
}

/// <summary>
/// Contains necessary information to create Hooks. Does not contain any hooks
/// </summary>
public static class Delegates
{
public sealed class Params_NotifyFetchComplete
{
public GameManager.SceneLoadInfo self;
}
public delegate void NotifyFetchComplete_BeforeArgs(Params_NotifyFetchComplete args);
public delegate void NotifyFetchComplete_AfterArgs(Params_NotifyFetchComplete args);
public delegate void NotifyFetchComplete_WithArgs (Action<GameManager.SceneLoadInfo> orig, GameManager.SceneLoadInfo self);
public sealed class Params_IsReadyToActivate
{
public GameManager.SceneLoadInfo self;
}
public delegate void IsReadyToActivate_BeforeArgs(Params_IsReadyToActivate args);
public delegate bool IsReadyToActivate_AfterArgs(Params_IsReadyToActivate args, bool ret);
public delegate bool IsReadyToActivate_WithArgs (Func<GameManager.SceneLoadInfo, bool> orig, GameManager.SceneLoadInfo self);
public sealed class Params_NotifyFinished
{
public GameManager.SceneLoadInfo self;
}
public delegate void NotifyFinished_BeforeArgs(Params_NotifyFinished args);
public delegate void NotifyFinished_AfterArgs(Params_NotifyFinished args);
public delegate void NotifyFinished_WithArgs (Action<GameManager.SceneLoadInfo> orig, GameManager.SceneLoadInfo self);
}

/// <summary>
/// Contains Hooks to that run code before orig(self) is called
/// </summary>
public static class BeforeOrig
{
public static event Delegates.NotifyFetchComplete_BeforeArgs NotifyFetchComplete
{
add
{

HookHandler._beforeNotifyFetchComplete += value;
HookHandler.HookNotifyFetchComplete();
}
remove => HookHandler._beforeNotifyFetchComplete -= value;
}
public static event Delegates.IsReadyToActivate_BeforeArgs IsReadyToActivate
{
add
{

HookHandler._beforeIsReadyToActivate += value;
HookHandler.HookIsReadyToActivate();
}
remove => HookHandler._beforeIsReadyToActivate -= value;
}
public static event Delegates.NotifyFinished_BeforeArgs NotifyFinished
{
add
{

HookHandler._beforeNotifyFinished += value;
HookHandler.HookNotifyFinished();
}
remove => HookHandler._beforeNotifyFinished -= value;
}
}

/// <summary>
/// Contains Hooks to that run code after orig(self) is called
/// </summary>
public static class AfterOrig
{
public static event Delegates.NotifyFetchComplete_AfterArgs NotifyFetchComplete
{
add
{

HookHandler._afterNotifyFetchComplete += value;
HookHandler.HookNotifyFetchComplete();
}
remove => HookHandler._afterNotifyFetchComplete -= value;
}
public static event Delegates.IsReadyToActivate_AfterArgs IsReadyToActivate
{
add
{

HookHandler._afterIsReadyToActivate += value;
HookHandler.HookIsReadyToActivate();
}
remove => HookHandler._afterIsReadyToActivate -= value;
}
public static event Delegates.NotifyFinished_AfterArgs NotifyFinished
{
add
{

HookHandler._afterNotifyFinished += value;
HookHandler.HookNotifyFinished();
}
remove => HookHandler._afterNotifyFinished -= value;
}
}

/// <summary>
/// Contains all On Hooks, even those that aren't in the On namespace such as API generated functions and property getters/setters
/// </summary>
public static class WithOrig
{
public static event Delegates.NotifyFetchComplete_WithArgs NotifyFetchComplete
{
add => HookEndpointManager.Add<Delegates.NotifyFetchComplete_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFetchComplete", true), value);
remove => HookEndpointManager.Remove<Delegates.NotifyFetchComplete_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFetchComplete", true), value);
}
public static event Delegates.IsReadyToActivate_WithArgs IsReadyToActivate
{
add => HookEndpointManager.Add<Delegates.IsReadyToActivate_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "IsReadyToActivate", true), value);
remove => HookEndpointManager.Remove<Delegates.IsReadyToActivate_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "IsReadyToActivate", true), value);
}
public static event Delegates.NotifyFinished_WithArgs NotifyFinished
{
add => HookEndpointManager.Add<Delegates.NotifyFinished_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFinished", true), value);
remove => HookEndpointManager.Remove<Delegates.NotifyFinished_WithArgs>(ReflectionHelper.GetMethodInfo(typeof(GameManager.SceneLoadInfo), "NotifyFinished", true), value);
}
}

}
